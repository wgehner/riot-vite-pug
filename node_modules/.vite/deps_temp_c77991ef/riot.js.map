{
  "version": 3,
  "sources": ["../../riot/esm/dependencies/@riotjs/util/constants.js", "../../riot/esm/dependencies/@riotjs/util/expression-types.js", "../../riot/esm/dependencies/@riotjs/util/strings.js", "../../riot/esm/dependencies/@riotjs/util/misc.js", "../../riot/esm/dependencies/@riotjs/util/checks.js", "../../riot/esm/dependencies/@riotjs/util/functions.js", "../../riot/esm/dependencies/@riotjs/util/dom.js", "../../riot/esm/core/mocked-template-interface.js", "../../riot/esm/dependencies/@riotjs/util/binding-types.js", "../../riot/esm/dependencies/@riotjs/util/objects.js", "../../riot/esm/dependencies/@riotjs/dom-bindings/dist/dom-bindings.js", "../../riot/esm/core/component-template-factory.js", "../../riot/esm/core/pure-component-api.js", "../../riot/esm/core/bind-dom-node-to-component-instance.js", "../../riot/esm/core/create-core-api-methods.js", "../../riot/esm/core/create-pure-component.js", "../../riot/esm/dependencies/bianco.dom-to-array/index.next.js", "../../riot/esm/dependencies/bianco.query/index.next.js", "../../riot/esm/core/component-dom-selectors.js", "../../riot/esm/core/component-lifecycle-methods.js", "../../riot/esm/dependencies/bianco.attr/index.next.js", "../../riot/esm/core/css-manager.js", "../../riot/esm/dependencies/curri/index.js", "../../riot/esm/utils/dom.js", "../../riot/esm/core/add-css-hook.js", "../../riot/esm/core/compute-component-state.js", "../../riot/esm/core/compute-initial-props.js", "../../riot/esm/core/create-attribute-bindings.js", "../../riot/esm/core/run-plugins.js", "../../riot/esm/utils/get-root-computed-attribute-names.js", "../../riot/esm/core/manage-component-lifecycle.js", "../../riot/esm/core/instantiate-component.js", "../../riot/esm/core/create-component-from-wrapper.js", "../../riot/esm/api/register.js", "../../riot/esm/api/unregister.js", "../../riot/esm/core/mount-component.js", "../../riot/esm/api/mount.js", "../../riot/esm/api/unmount.js", "../../riot/esm/api/install.js", "../../riot/esm/api/uninstall.js", "../../riot/esm/dependencies/cumpa/index.js", "../../riot/esm/api/component.js", "../../riot/esm/api/pure.js", "../../riot/esm/api/with-types.js", "../../riot/esm/api/version.js", "../../riot/esm/api/__.js"],
  "sourcesContent": ["/* Riot WIP, @license MIT */\n// Riot.js constants that can be used across more modules\n\nconst COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n  DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n  PLUGINS_SET = new Set(),\n  IS_DIRECTIVE = 'is',\n  MOUNT_METHOD_KEY = 'mount',\n  UPDATE_METHOD_KEY = 'update',\n  UNMOUNT_METHOD_KEY = 'unmount',\n  SHOULD_UPDATE_KEY = 'shouldUpdate',\n  ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n  ON_MOUNTED_KEY = 'onMounted',\n  ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n  ON_UPDATED_KEY = 'onUpdated',\n  ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n  ON_UNMOUNTED_KEY = 'onUnmounted',\n  PROPS_KEY = 'props',\n  STATE_KEY = 'state',\n  SLOTS_KEY = 'slots',\n  ROOT_KEY = 'root',\n  IS_PURE_SYMBOL = Symbol('pure'),\n  IS_COMPONENT_UPDATING = Symbol('is_updating'),\n  PARENT_KEY_SYMBOL = Symbol('parent'),\n  ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n  TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nexport { ATTRIBUTES_KEY_SYMBOL, COMPONENTS_IMPLEMENTATION_MAP, DOM_COMPONENT_INSTANCE_PROPERTY, IS_COMPONENT_UPDATING, IS_DIRECTIVE, IS_PURE_SYMBOL, MOUNT_METHOD_KEY, ON_BEFORE_MOUNT_KEY, ON_BEFORE_UNMOUNT_KEY, ON_BEFORE_UPDATE_KEY, ON_MOUNTED_KEY, ON_UNMOUNTED_KEY, ON_UPDATED_KEY, PARENT_KEY_SYMBOL, PLUGINS_SET, PROPS_KEY, ROOT_KEY, SHOULD_UPDATE_KEY, SLOTS_KEY, STATE_KEY, TEMPLATE_KEY_SYMBOL, UNMOUNT_METHOD_KEY, UPDATE_METHOD_KEY };\n", "/* Riot WIP, @license MIT */\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\n\nconst expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE,\n};\n\nexport { ATTRIBUTE, EVENT, TEXT, VALUE, expressionTypes as default };\n", "/* Riot WIP, @license MIT */\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase())\n}\n\nexport { camelToDashCase, dashToCamelCase };\n", "/* Riot WIP, @license MIT */\nimport { VALUE, ATTRIBUTE } from './expression-types.js';\nimport { dashToCamelCase } from './strings.js';\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @param   { string } cause - optional error cause object\n * @returns { undefined } hoppla... at this point the program should stop working\n */\nfunction panic(message, cause) {\n  throw new Error(message, { cause })\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\nfunction memoize(fn) {\n  const cache = new Map();\n  const cached = (val) => {\n    return cache.has(val)\n      ? cache.get(val)\n      : cache.set(val, fn.call(this, val)) && cache.get(val)\n  };\n  cached.cache = cache;\n  return cached\n}\n\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const { value, type } = attribute;\n\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === ATTRIBUTE:\n        return {\n          ...acc,\n          ...value,\n        }\n      // value attribute\n      case type === VALUE:\n        acc.value = attribute.value;\n        break\n      // normal attributes\n      default:\n        acc[dashToCamelCase(attribute.name)] = attribute.value;\n    }\n\n    return acc\n  }, {})\n}\n\nexport { evaluateAttributeExpressions, memoize, panic };\n", "/* Riot WIP, @license MIT */\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type\n}\n\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n\n  return !!owner || owner === null\n}\n\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\nfunction isTemplate(el) {\n  return el.tagName.toLowerCase() === 'template'\n}\n\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\nfunction isFunction(value) {\n  return checkType(value, 'function')\n}\n\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\nfunction isBoolean(value) {\n  return checkType(value, 'boolean')\n}\n\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\nfunction isObject(value) {\n  return !isNil(value) && value.constructor === Object\n}\n\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\nfunction isNil(value) {\n  return value === null || value === undefined\n}\n\nexport { checkType, isBoolean, isFunction, isNil, isObject, isSvg, isTemplate };\n", "/* Riot WIP, @license MIT */\nimport { isFunction } from './checks.js';\n\n// does simply nothing\nfunction noop() {\n  return this\n}\n\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\nfunction autobindMethods(source, methods) {\n  methods.forEach((method) => {\n    source[method] = source[method].bind(source);\n  });\n\n  return source\n}\n\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\nfunction callOrAssign(source) {\n  return isFunction(source)\n    ? source.prototype && source.prototype.constructor\n      ? new source()\n      : source()\n    : source\n}\n\nexport { autobindMethods, callOrAssign, noop };\n", "/* Riot WIP, @license MIT */\nimport { dashToCamelCase } from './strings.js';\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value;\n    return acc\n  }, {})\n}\n\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method Â¯\\_(ãƒ„)_/Â¯\n */\n\n// Ignore this helper because it's needed only for svg tags\nfunction moveChildren(source, target) {\n  // eslint-disable-next-line fp/no-loops\n  while (source.firstChild) target.appendChild(source.firstChild);\n}\n\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\nfunction cleanNode(node) {\n  // eslint-disable-next-line fp/no-loops\n  while (node.firstChild) node.removeChild(node.firstChild);\n}\n\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\nfunction clearChildren(children) {\n  // eslint-disable-next-line fp/no-loops,fp/no-let\n  for (let i = 0; i < children.length; i++) removeChild(children[i]);\n}\n\n/**\n * Remove a node\n * @param {HTMLElement}node - node to remove\n * @returns {undefined}\n */\nconst removeChild = (node) => node.remove();\n\n/**\n * Insert before a node\n * @param {HTMLElement} newNode - node to insert\n * @param {HTMLElement} refNode - ref child\n * @returns {undefined}\n */\nconst insertBefore = (newNode, refNode) =>\n  refNode &&\n  refNode.parentNode &&\n  refNode.parentNode.insertBefore(newNode, refNode);\n\n/**\n * Replace a node\n * @param {HTMLElement} newNode - new node to add to the DOM\n * @param {HTMLElement} replaced - node to replace\n * @returns {undefined}\n */\nconst replaceChild = (newNode, replaced) =>\n  replaced &&\n  replaced.parentNode &&\n  replaced.parentNode.replaceChild(newNode, replaced);\n\nexport { DOMattributesToObject, cleanNode, clearChildren, insertBefore, moveChildren, removeChild, replaceChild };\n", "/* Riot v9.1.8, @license MIT */\nimport { MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY } from '../dependencies/@riotjs/util/constants.js';\nimport { removeChild, cleanNode } from '../dependencies/@riotjs/util/dom.js';\nimport { noop } from '../dependencies/@riotjs/util/functions.js';\n\n// Components without template use a mocked template interface with some basic functionalities to\n// guarantee consistent rendering behaviour see https://github.com/riot/riot/issues/2984\nconst MOCKED_TEMPLATE_INTERFACE = {\n  [MOUNT_METHOD_KEY](el) {\n    this.el = el;\n  },\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY](_, __, mustRemoveRoot = false) {\n    if (mustRemoveRoot) removeChild(this.el);\n    else if (!mustRemoveRoot) cleanNode(this.el);\n  },\n  clone: noop,\n  createDOM: noop,\n};\n\nexport { MOCKED_TEMPLATE_INTERFACE };\n", "/* Riot WIP, @license MIT */\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\n\nconst bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT,\n};\n\nexport { EACH, IF, SIMPLE, SLOT, TAG, bindingTypes as default };\n", "/* Riot WIP, @license MIT */\nimport { isObject } from './checks.js';\n\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the property overriding the default options\n * @returns {Object} - the original object modified\n */\nfunction defineProperty(source, key, value, options = {}) {\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, {\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true,\n    ...options,\n  });\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source\n}\n\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the property overriding the default options\n * @returns {Object} the original object modified\n */\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach(([key, value]) => {\n    defineProperty(source, key, value, options);\n  });\n\n  return source\n}\n\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach(([key, value]) => {\n    if (!source[key]) source[key] = value;\n  });\n\n  return source\n}\n\n/**\n * Generate a new object picking only the properties from a given array\n * @param {Object} source - target object\n * @param {Array} keys - list of keys that we want to copy over to the new object\n * @return {Object} a new object conaining only the keys that we have picked from the keys array list\n */\nfunction pick(source, keys) {\n  return isObject(source)\n    ? Object.fromEntries(keys.map((key) => [key, source[key]]))\n    : source\n}\n\nexport { defineDefaults, defineProperties, defineProperty, pick };\n", "/* Riot WIP, @license MIT */\nimport { removeChild, cleanNode, clearChildren, insertBefore, moveChildren, replaceChild } from '../../util/dom.js';\nimport { IS_PURE_SYMBOL, PARENT_KEY_SYMBOL } from '../../util/constants.js';\nimport { SIMPLE, IF, EACH, TAG, SLOT } from '../../util/binding-types.js';\nexport { default as bindingTypes } from '../../util/binding-types.js';\nimport { TEXT, EVENT, ATTRIBUTE, VALUE } from '../../util/expression-types.js';\nexport { default as expressionTypes } from '../../util/expression-types.js';\nimport { defineProperty } from '../../util/objects.js';\nimport { isTemplate, isSvg, isBoolean, isObject, isFunction, isNil } from '../../util/checks.js';\nimport { panic, memoize, evaluateAttributeExpressions } from '../../util/misc.js';\n\nconst HEAD_SYMBOL = Symbol();\nconst TAIL_SYMBOL = Symbol();\n\n/**\n * Create the <template> fragments text nodes\n * @return {Object} {{head: Text, tail: Text}}\n */\nfunction createHeadTailPlaceholders() {\n  const head = document.createTextNode('');\n  const tail = document.createTextNode('');\n\n  head[HEAD_SYMBOL] = true;\n  tail[TAIL_SYMBOL] = true;\n\n  return { head, tail }\n}\n\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk\n */\nfunction createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true);\n  const { head, tail } = createHeadTailPlaceholders();\n\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    head,\n    tail,\n    children: [head, ...Array.from(fragment.childNodes), tail],\n  }\n}\n\n/* c8 ignore start */\n/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n// fork of https://github.com/WebReflection/udomdiff version 1.1.0\n// due to https://github.com/WebReflection/udomdiff/pull/2\n/* eslint-disable */\n\n/**\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nconst udomdiff = (a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node =\n        bEnd < bLength\n          ? bStart\n            ? get(b[bStart - 1], -0).nextSibling\n            : get(b[bEnd - bStart], 0)\n          : before;\n      while (bStart < bEnd) insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart])) removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      insertBefore(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);\n      insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap ðŸ‘)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence)\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > index - bStart) {\n            const node = get(a[aStart], 0);\n            while (bStart < index) insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            replaceChild(get(b[bStart++], 1), get(a[aStart++], -1));\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b\n};\n\nconst UNMOUNT_SCOPE = Symbol('unmount');\n\nconst EachBinding = {\n  // dynamic binding properties\n  // childrenMap: null,\n  // node: null,\n  // root: null,\n  // condition: null,\n  // evaluate: null,\n  // template: null,\n  // isTemplateTag: false,\n  nodes: [],\n  // getKey: null,\n  // indexName: null,\n  // itemName: null,\n  // afterPlaceholder: null,\n  // placeholder: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope)\n  },\n  update(scope, parentScope) {\n    const { placeholder, nodes, childrenMap } = this;\n    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);\n    const items = collection ? Array.from(collection) : [];\n\n    // prepare the diffing\n    const { newChildrenMap, batches, futureNodes } = createPatch(\n      items,\n      scope,\n      parentScope,\n      this,\n    );\n\n    // patch the DOM only if there are new nodes\n    udomdiff(\n      nodes,\n      futureNodes,\n      patch(Array.from(childrenMap.values()), parentScope),\n      placeholder,\n    );\n\n    // trigger the mounts and the updates\n    batches.forEach((fn) => fn());\n\n    // update the children map\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n\n    return this\n  },\n  unmount(scope, parentScope) {\n    this.update(UNMOUNT_SCOPE, parentScope);\n\n    return this\n  },\n};\n\n/**\n * Patch the DOM while diffing\n * @param   {any[]} redundant - list of all the children (template, nodes, context) added via each\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      // get the last element added to the childrenMap saved previously\n      const element = redundant[redundant.length - 1];\n\n      if (element) {\n        // get the nodes and the template in stored in the last child of the childrenMap\n        const { template, nodes, context } = element;\n        // remove the last node (notice <template> tags might have more children nodes)\n        nodes.pop();\n\n        // notice that we pass null as last argument because\n        // the root node and its children will be removed by domdiff\n        if (!nodes.length) {\n          // we have cleared all the children nodes and we can unmount this template\n          redundant.pop();\n          template.unmount(context, parentScope, null);\n        }\n      }\n    }\n\n    return item\n  }\n}\n\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\nfunction mustFilterItem(condition, context) {\n  return condition ? !condition(context) : false\n}\n\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {Object} options - options\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\nfunction extendScope(scope, { itemName, indexName, index, item }) {\n  defineProperty(scope, itemName, item);\n  if (indexName) defineProperty(scope, indexName, index);\n\n  return scope\n}\n\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root,\n    isTemplateTag,\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item,\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n    const nodes = [];\n\n    if (mustFilterItem(condition, context)) {\n      return\n    }\n\n    const mustMount = !oldItem;\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = componentTemplate.el || root.cloneNode();\n    const meta =\n      isTemplateTag && mustMount\n        ? createTemplateMeta(componentTemplate)\n        : componentTemplate.meta;\n\n    if (mustMount) {\n      batches.push(() =>\n        componentTemplate.mount(el, context, parentScope, meta),\n      );\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    }\n\n    // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n    if (isTemplateTag) {\n      nodes.push(...meta.children);\n    } else {\n      nodes.push(el);\n    }\n\n    // delete the old item from the children map\n    childrenMap.delete(key);\n    futureNodes.push(...nodes);\n\n    // update the children map\n    newChildrenMap.set(key, {\n      nodes,\n      template: componentTemplate,\n      context,\n      index,\n    });\n  });\n\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes,\n  }\n}\n\nfunction create$6(\n  node,\n  { evaluate, condition, itemName, indexName, getKey, template },\n) {\n  const placeholder = document.createTextNode('');\n  const root = node.cloneNode();\n\n  insertBefore(placeholder, node);\n  removeChild(node);\n\n  return {\n    ...EachBinding,\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: isTemplate(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder,\n  }\n}\n\n/**\n * Binding responsible for the `if` directive\n */\nconst IfBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // isTemplateTag: false,\n  // placeholder: null,\n  // template: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope)\n  },\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n    const mount = () => {\n      const pristine = this.node.cloneNode();\n\n      insertBefore(pristine, this.placeholder);\n      this.template = this.template.clone();\n      this.template.mount(pristine, scope, parentScope);\n    };\n\n    switch (true) {\n      case mustMount:\n        mount();\n        break\n      case mustUnmount:\n        this.unmount(scope);\n        break\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n\n    return this\n  },\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope, true);\n\n    return this\n  },\n};\n\nfunction create$5(node, { evaluate, template }) {\n  const placeholder = document.createTextNode('');\n\n  insertBefore(placeholder, node);\n  removeChild(node);\n\n  return {\n    ...IfBinding,\n    node,\n    evaluate,\n    placeholder,\n    template: template.createDOM(node),\n  }\n}\n\n/* c8 ignore next */\nconst ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;\nconst isNativeHtmlProperty = memoize(\n  (name) => ElementProto.hasOwnProperty(name), // eslint-disable-line\n);\n\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\nfunction setAllAttributes(node, attributes) {\n  Object.keys(attributes).forEach((name) =>\n    attributeExpression(node, { name }, attributes[name]),\n  );\n}\n\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} newAttributes - object containing all the new attribute names\n * @param   {Object} oldAttributes - object containing all the old attribute names\n * @returns {undefined} sorry it's a void function :(\n */\nfunction removeAllAttributes(node, newAttributes, oldAttributes) {\n  const newKeys = newAttributes ? Object.keys(newAttributes) : [];\n\n  Object.keys(oldAttributes)\n    .filter((name) => !newKeys.includes(name))\n    .forEach((attribute) => node.removeAttribute(attribute));\n}\n\n/**\n * Check whether the attribute value can be rendered\n * @param {*} value - expression value\n * @returns {boolean} true if we can render this attribute value\n */\nfunction canRenderAttribute(value) {\n  return ['string', 'number', 'boolean'].includes(typeof value)\n}\n\n/**\n * Check whether the attribute should be removed\n * @param {*} value - expression value\n * @param   {boolean} isBoolean - flag to handle boolean attributes\n * @returns {boolean} boolean - true if the attribute can be removed}\n */\nfunction shouldRemoveAttribute(value, isBoolean) {\n  // boolean attributes should be removed if the value is falsy\n  if (isBoolean) return !value && value !== 0\n  // otherwise we can try to render it\n  return typeof value === 'undefined' || value === null\n}\n\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {boolean} expression.isBoolean - flag to handle boolean attributes\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\nfunction attributeExpression(\n  node,\n  { name, isBoolean: isBoolean$1 },\n  value,\n  oldValue,\n) {\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    if (oldValue) {\n      // remove all the old attributes\n      removeAllAttributes(node, value, oldValue);\n    }\n\n    // is the value still truthy?\n    if (value) {\n      setAllAttributes(node, value);\n    }\n\n    return\n  }\n\n  // store the attribute on the node to make it compatible with native custom elements\n  if (\n    !isNativeHtmlProperty(name) &&\n    (isBoolean(value) || isObject(value) || isFunction(value))\n  ) {\n    node[name] = value;\n  }\n\n  if (shouldRemoveAttribute(value, isBoolean$1)) {\n    node.removeAttribute(name);\n  } else if (canRenderAttribute(value)) {\n    node.setAttribute(name, normalizeValue(name, value, isBoolean$1));\n  }\n}\n\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @param   {boolean} isBoolean - boolean attributes flag\n * @returns {string} input value as string\n */\nfunction normalizeValue(name, value, isBoolean) {\n  // be sure that expressions like selected={ true } will always be rendered as selected='selected'\n  // fix https://github.com/riot/riot/issues/2975\n  return value === true && isBoolean ? name : value\n}\n\nconst RE_EVENTS_PREFIX = /^on/;\n\nconst getCallbackAndOptions = (value) =>\n  Array.isArray(value) ? value : [value, false];\n\n// see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\nconst EventListener = {\n  handleEvent(event) {\n    this[event.type](event);\n  },\n};\nconst ListenersWeakMap = new WeakMap();\n\nconst createListener = (node) => {\n  const listener = Object.create(EventListener);\n  ListenersWeakMap.set(node, listener);\n  return listener\n};\n\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {value} the callback just received\n */\nfunction eventExpression(node, { name }, value) {\n  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');\n  const eventListener = ListenersWeakMap.get(node) || createListener(node);\n  const [callback, options] = getCallbackAndOptions(value);\n  const handler = eventListener[normalizedEventName];\n  const mustRemoveEvent = handler && !callback;\n  const mustAddEvent = callback && !handler;\n\n  if (mustRemoveEvent) {\n    node.removeEventListener(normalizedEventName, eventListener);\n  }\n\n  if (mustAddEvent) {\n    node.addEventListener(normalizedEventName, eventListener, options);\n  }\n\n  eventListener[normalizedEventName] = callback;\n}\n\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\nfunction normalizeStringValue(value) {\n  return isNil(value) ? '' : value\n}\n\n/**\n * Get the the target text node to update or create one from of a comment node\n * @param   {HTMLElement} node - any html element containing childNodes\n * @param   {number} childNodeIndex - index of the text node in the childNodes list\n * @returns {Text} the text node to update\n */\nconst getTextNode = (node, childNodeIndex) => {\n  return node.childNodes[childNodeIndex]\n};\n\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} data - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction textExpression(node, data, value) {\n  node.data = normalizeStringValue(value);\n}\n\n/**\n * This methods handles the input fields value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction valueExpression(node, expression, value) {\n  node.value = normalizeStringValue(value);\n}\n\nconst expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression,\n};\n\nconst Expression = {\n  // Static props\n  // node: null,\n  // value: null,\n\n  // API methods\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope);\n\n    // IO() DOM updates\n    apply(this, this.value);\n\n    return this\n  },\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this\n  },\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    // unmount only the event handling expressions\n    if (this.type === EVENT) apply(this, null);\n\n    return this\n  },\n};\n\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\nfunction apply(expression, value) {\n  return expressions[expression.type](\n    expression.node,\n    expression,\n    value,\n    expression.value,\n  )\n}\n\nfunction create$4(node, data) {\n  return {\n    ...Expression,\n    ...data,\n    node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node,\n  }\n}\n\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return {\n      ...acc,\n      [method]: (scope) => {\n        return collection.map((item) => item[method](scope)) && context\n      },\n    }\n  }, {})\n}\n\nfunction create$3(node, { expressions }) {\n  return flattenCollectionMethods(\n    expressions.map((expression) => create$4(node, expression)),\n    ['mount', 'update', 'unmount'],\n  )\n}\n\nfunction extendParentScope(attributes, scope, parentScope) {\n  if (!attributes || !attributes.length) return parentScope\n\n  const expressions = attributes.map((attr) => ({\n    ...attr,\n    value: attr.evaluate(scope),\n  }));\n\n  return Object.assign(\n    Object.create(parentScope || null),\n    evaluateAttributeExpressions(expressions),\n  )\n}\n\n// this function is only meant to fix an edge case\n// https://github.com/riot/riot/issues/2842\nconst getRealParent = (scope, parentScope) =>\n  scope[PARENT_KEY_SYMBOL] || parentScope;\n\nconst SlotBinding = {\n  // dynamic binding properties\n  // node: null,\n  // name: null,\n  attributes: [],\n  // template: null,\n\n  getTemplateScope(scope, parentScope) {\n    return extendParentScope(this.attributes, scope, parentScope)\n  },\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots\n      ? scope.slots.find(({ id }) => id === this.name)\n      : false;\n    const { parentNode } = this.node;\n    const realParent = getRealParent(scope, parentScope);\n\n    this.template =\n      templateData &&\n      create(templateData.html, templateData.bindings).createDOM(parentNode);\n\n    if (this.template) {\n      cleanNode(this.node);\n      this.template.mount(\n        this.node,\n        this.getTemplateScope(scope, realParent),\n        realParent,\n      );\n      this.template.children = Array.from(this.node.childNodes);\n    }\n\n    moveSlotInnerContent(this.node);\n    removeChild(this.node);\n\n    return this\n  },\n  update(scope, parentScope) {\n    if (this.template) {\n      const realParent = getRealParent(scope, parentScope);\n      this.template.update(this.getTemplateScope(scope, realParent), realParent);\n    }\n\n    return this\n  },\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(\n        this.getTemplateScope(scope, parentScope),\n        null,\n        mustRemoveRoot,\n      );\n    }\n\n    return this\n  },\n};\n\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLElement} slot - slot node\n * @returns {undefined} it's a void method Â¯\\_(ãƒ„)_/Â¯\n */\nfunction moveSlotInnerContent(slot) {\n  const child = slot && slot.firstChild;\n\n  if (!child) return\n\n  insertBefore(child, slot);\n  moveSlotInnerContent(slot);\n}\n\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} name - slot id\n * @param   {AttributeExpressionData[]} attributes - slot attributes\n * @returns {Object} Slot binding object\n */\nfunction createSlot(node, { name, attributes }) {\n  return {\n    ...SlotBinding,\n    attributes,\n    node,\n    name,\n  }\n}\n\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\nfunction getTag(component, slots = [], attributes = []) {\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({ slots, attributes })\n  }\n\n  // otherwise we return a template chunk\n  return create(slotsToMarkup(slots), [\n    ...slotBindings(slots),\n    {\n      // the attributes should be registered as binding\n      // if we fallback to a normal template chunk\n      expressions: attributes.map((attr) => {\n        return {\n          type: ATTRIBUTE,\n          ...attr,\n        }\n      }),\n    },\n  ])\n}\n\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\nfunction slotBindings(slots) {\n  return slots.reduce((acc, { bindings }) => acc.concat(bindings), [])\n}\n\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html\n  }, '')\n}\n\nconst TagBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // name: null,\n  // slots: null,\n  // tag: null,\n  // attributes: null,\n  // getComponent: null,\n\n  mount(scope) {\n    return this.update(scope)\n  },\n  update(scope, parentScope) {\n    const name = this.evaluate(scope);\n\n    // simple update\n    if (name && name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true);\n\n      // mount the new tag\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this\n  },\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag);\n    }\n\n    return this\n  },\n};\n\nfunction create$2(\n  node,\n  { evaluate, getComponent, slots, attributes },\n) {\n  return {\n    ...TagBinding,\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent,\n  }\n}\n\nconst bindings = {\n  [IF]: create$5,\n  [SIMPLE]: create$3,\n  [EACH]: create$6,\n  [TAG]: create$2,\n  [SLOT]: createSlot,\n};\n\n/**\n * Text expressions in a template tag will get childNodeIndex value normalized\n * depending on the position of the <template> tag offset\n * @param   {Expression[]} expressions - riot expressions array\n * @param   {number} textExpressionsOffset - offset of the <template> tag\n * @returns {Expression[]} expressions containing the text expressions normalized\n */\nfunction fixTextExpressionsOffset(expressions, textExpressionsOffset) {\n  return expressions.map((e) =>\n    e.type === TEXT\n      ? {\n          ...e,\n          childNodeIndex: e.childNodeIndex + textExpressionsOffset,\n        }\n      : e,\n  )\n}\n\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {TagBindingData} binding - binding data\n * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset\n * @returns {Binding} Binding object\n */\nfunction create$1(root, binding, templateTagOffset) {\n  const { selector, type, redundantAttribute, expressions } = binding;\n  // find the node to apply the bindings\n  const node = selector ? root.querySelector(selector) : root;\n\n  // remove eventually additional attributes created only to select this node\n  if (redundantAttribute) node.removeAttribute(redundantAttribute);\n  const bindingExpressions = expressions || [];\n\n  // init the binding\n  return (bindings[type] || bindings[SIMPLE])(node, {\n    ...binding,\n    expressions:\n      templateTagOffset && !selector\n        ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset)\n        : bindingExpressions,\n  })\n}\n\n// in this case a simple innerHTML is enough\nfunction createHTMLTree(html, root) {\n  const template = isTemplate(root) ? root : document.createElement('template');\n  template.innerHTML = html;\n  return template.content\n}\n\n// for svg nodes we need a bit more work\n/* c8 ignore start */\nfunction createSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(\n    new window.DOMParser().parseFromString(\n      `<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`,\n      'application/xml',\n    ).documentElement,\n    true,\n  );\n\n  return svgNode\n}\n/* c8 ignore end */\n\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\nfunction createDOMTree(root, html) {\n  /* c8 ignore next */\n  if (isSvg(root)) return createSVGTree(html, root)\n\n  return createHTMLTree(html, root)\n}\n\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {DocumentFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\nfunction injectDOM(el, dom) {\n  switch (true) {\n    case isSvg(el):\n      moveChildren(dom, el);\n      break\n    case isTemplate(el):\n      el.parentNode.replaceChild(dom, el);\n      break\n    default:\n      el.appendChild(dom);\n  }\n}\n\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string|HTMLElement} html - HTML markup or HTMLElement that will be injected into the root node\n * @returns {?DocumentFragment} fragment that will be injected into the root node\n */\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html)\n}\n\n/**\n * Get the offset of the <template> tag\n * @param {HTMLElement} parentNode - template tag parent node\n * @param {HTMLElement} el - the template tag we want to render\n * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n * @returns {number} offset of the <template> tag calculated from its siblings DOM nodes\n */\nfunction getTemplateTagOffset(parentNode, el, meta) {\n  const siblings = Array.from(parentNode.childNodes);\n\n  return Math.max(siblings.indexOf(el), siblings.indexOf(meta.head) + 1, 0)\n}\n\n/**\n * Template Chunk model\n * @type {Object}\n */\nconst TemplateChunk = {\n  // Static props\n  // bindings: null,\n  // bindingsData: null,\n  // html: null,\n  // isTemplateTag: false,\n  // fragment: null,\n  // children: null,\n  // dom: null,\n  // el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom =\n      this.dom ||\n      createTemplateDOM(el, this.html) ||\n      document.createDocumentFragment();\n\n    return this\n  },\n\n  // API methods\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta = {}) {\n    if (!el) panic('Please provide DOM node to mount properly your template');\n\n    if (this.el) this.unmount(scope);\n\n    // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n    const { fragment, children, avoidDOMInjection } = meta;\n    // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n    const { parentNode } = children ? children[0] : el;\n    const isTemplateTag = isTemplate(el);\n    const templateTagOffset = isTemplateTag\n      ? getTemplateTagOffset(parentNode, el, meta)\n      : null;\n\n    // create the DOM if it wasn't created before\n    this.createDOM(el);\n\n    // create the DOM of this template cloning the original DOM structure stored in this instance\n    // notice that if a documentFragment was passed (via meta) we will use it instead\n    const cloneNode = fragment || this.dom.cloneNode(true);\n\n    // store root node\n    // notice that for template tags the root note will be the parent tag\n    this.el = isTemplateTag ? parentNode : el;\n\n    // create the children array only for the <template> fragments\n    this.children = isTemplateTag\n      ? children || Array.from(cloneNode.childNodes)\n      : null;\n\n    // inject the DOM into the el only if a fragment is available\n    if (!avoidDOMInjection && cloneNode) injectDOM(el, cloneNode);\n\n    // create the bindings\n    this.bindings = this.bindingsData.map((binding) =>\n      create$1(this.el, binding, templateTagOffset),\n    );\n    this.bindings.forEach((b) => b.mount(scope, parentScope));\n\n    // store the template meta properties\n    this.meta = meta;\n\n    return this\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach((b) => b.update(scope, parentScope));\n\n    return this\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot = false) {\n    const el = this.el;\n\n    if (!el) {\n      return this\n    }\n\n    this.bindings.forEach((b) => b.unmount(scope, parentScope, mustRemoveRoot));\n\n    switch (true) {\n      // pure components should handle the DOM unmount updates by themselves\n      // for mustRemoveRoot === null don't touch the DOM\n      case el[IS_PURE_SYMBOL] || mustRemoveRoot === null:\n        break\n\n      // if children are declared, clear them\n      // applicable for <template> and <slot/> bindings\n      case Array.isArray(this.children):\n        clearChildren(this.children);\n        break\n\n      // clean the node children only\n      case !mustRemoveRoot:\n        cleanNode(el);\n        break\n\n      // remove the root node only if the mustRemoveRoot is truly\n      case !!mustRemoveRoot:\n        removeChild(el);\n        break\n    }\n\n    this.el = null;\n\n    return this\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return {\n      ...this,\n      meta: {},\n      el: null,\n    }\n  },\n};\n\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {BindingData[]} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\nfunction create(html, bindings = []) {\n  return {\n    ...TemplateChunk,\n    html,\n    bindingsData: bindings,\n  }\n}\n\nexport { create$1 as createBinding, create$4 as createExpression, create as template };\n", "/* Riot v9.1.8, @license MIT */\nimport { template as create } from '../dependencies/@riotjs/dom-bindings/dist/dom-bindings.js';\nimport expressionTypes from '../dependencies/@riotjs/util/expression-types.js';\nimport bindingTypes from '../dependencies/@riotjs/util/binding-types.js';\n\n/**\n * Factory function to create the component templates only once\n * @param   {Function} template - component template creation function\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @param   {Function} getChildComponent - getter function to return the children components\n * @returns {TemplateChunk} template chunk object\n */\nfunction componentTemplateFactory(\n  template,\n  componentWrapper,\n  getChildComponent,\n) {\n  return template(\n    create,\n    expressionTypes,\n    bindingTypes,\n    getChildComponent,\n  )\n}\n\nexport { componentTemplateFactory };\n", "/* Riot v9.1.8, @license MIT */\nimport { MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY } from '../dependencies/@riotjs/util/constants.js';\nimport { noop } from '../dependencies/@riotjs/util/functions.js';\n\nconst PURE_COMPONENT_API = Object.freeze({\n  [MOUNT_METHOD_KEY]: noop,\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY]: noop,\n});\n\nexport { PURE_COMPONENT_API };\n", "/* Riot v9.1.8, @license MIT */\nimport { DOM_COMPONENT_INSTANCE_PROPERTY } from '../dependencies/@riotjs/util/constants.js';\n\n/**\n * Bind a DOM node to its component object\n * @param   {HTMLElement} node - html node mounted\n * @param   {Object} component - Riot.js component object\n * @returns {Object} the component object received as second argument\n */\nconst bindDOMNodeToComponentInstance = (node, component) =>\n  (node[DOM_COMPONENT_INSTANCE_PROPERTY] = component);\n\nexport { bindDOMNodeToComponentInstance };\n", "/* Riot v9.1.8, @license MIT */\nimport { MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY } from '../dependencies/@riotjs/util/constants.js';\n\n/**\n * Wrap the Riot.js core API methods using a mapping function\n * @param   {Function} mapFunction - lifting function\n * @returns {Object} an object having the { mount, update, unmount } functions\n */\nfunction createCoreAPIMethods(mapFunction) {\n  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce(\n    (acc, method) => {\n      acc[method] = mapFunction(method);\n\n      return acc\n    },\n    {},\n  )\n}\n\nexport { createCoreAPIMethods };\n", "/* Riot v9.1.8, @license MIT */\nimport { MOUNT_METHOD_KEY, IS_PURE_SYMBOL } from '../dependencies/@riotjs/util/constants.js';\nimport { panic } from '../dependencies/@riotjs/util/misc.js';\nimport { defineDefaults, defineProperty } from '../dependencies/@riotjs/util/objects.js';\nimport { PURE_COMPONENT_API } from './pure-component-api.js';\nimport { bindDOMNodeToComponentInstance } from './bind-dom-node-to-component-instance.js';\nimport { createCoreAPIMethods } from './create-core-api-methods.js';\n\n/**\n * Create a pure component\n * @param   {Function} pureFactoryFunction - pure component factory function\n * @param   {Array} options.slots - component slots\n * @param   {Array} options.attributes - component attributes\n * @param   {Array} options.template - template factory function\n * @param   {Array} options.template - template factory function\n * @param   {any} options.props - initial component properties\n * @returns {Object} pure component object\n */\nfunction createPureComponent(\n  pureFactoryFunction,\n  { slots, attributes, props, css, template },\n) {\n  if (template) panic('Pure components can not have html');\n  if (css) panic('Pure components do not have css');\n\n  const component = defineDefaults(\n    pureFactoryFunction({ slots, attributes, props }),\n    PURE_COMPONENT_API,\n  );\n\n  return createCoreAPIMethods((method) => (...args) => {\n    // intercept the mount calls to bind the DOM node to the pure object created\n    // see also https://github.com/riot/riot/issues/2806\n    if (method === MOUNT_METHOD_KEY) {\n      const [element] = args;\n      // mark this node as pure element\n      defineProperty(element, IS_PURE_SYMBOL, true);\n      bindDOMNodeToComponentInstance(element, component);\n    }\n\n    component[method](...args);\n\n    return component\n  })\n}\n\nexport { createPureComponent };\n", "/* Riot WIP, @license MIT */\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (\n      /^\\[object (HTMLCollection|NodeList|Object)\\]$/\n        .test(Object.prototype.toString.call(els))\n        && typeof els.length === 'number'\n    )\n      return Array.from(els)\n    else\n      // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els]\n  }\n  // this object could be looped out of the box\n  return els\n}\n\nexport { domToArray as default };\n", "/* Riot WIP, @license MIT */\nimport domToArray from '../bianco.dom-to-array/index.next.js';\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        scope      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\nfunction $(selector, scope) {\n  return domToArray(typeof selector === 'string' ?\n    (scope || document).querySelectorAll(selector) :\n    selector\n  )\n}\n\nexport { $ as default };\n", "/* Riot v9.1.8, @license MIT */\nimport $ from '../dependencies/bianco.query/index.next.js';\n\nconst COMPONENT_DOM_SELECTORS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0]\n  },\n  $$(selector) {\n    return $(selector, this.root)\n  },\n});\n\nexport { COMPONENT_DOM_SELECTORS };\n", "/* Riot v9.1.8, @license MIT */\nimport { SHOULD_UPDATE_KEY, ON_BEFORE_MOUNT_KEY, ON_MOUNTED_KEY, ON_BEFORE_UPDATE_KEY, ON_UPDATED_KEY, ON_BEFORE_UNMOUNT_KEY, ON_UNMOUNTED_KEY } from '../dependencies/@riotjs/util/constants.js';\nimport { noop } from '../dependencies/@riotjs/util/functions.js';\n\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  [SHOULD_UPDATE_KEY]: noop,\n  [ON_BEFORE_MOUNT_KEY]: noop,\n  [ON_MOUNTED_KEY]: noop,\n  [ON_BEFORE_UPDATE_KEY]: noop,\n  [ON_UPDATED_KEY]: noop,\n  [ON_BEFORE_UNMOUNT_KEY]: noop,\n  [ON_UNMOUNTED_KEY]: noop,\n});\n\nexport { COMPONENT_LIFECYCLE_METHODS };\n", "/* Riot WIP, @license MIT */\nimport domToArray from '../bianco.dom-to-array/index.next.js';\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\nconst normalize = values => values.length === 1 ? values[0] : values;\n\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)))\n  }))\n}\n\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : { [name]: value };\n  const props = Object.keys(attrs);\n\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els\n}\n\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute')\n}\n\nexport { get, set };\n", "/* Riot v9.1.8, @license MIT */\nimport $ from '../dependencies/bianco.query/index.next.js';\nimport { set } from '../dependencies/bianco.attr/index.next.js';\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]';\n\n// memoized curried function\nconst getStyleNode = ((style) => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style\n\n    // create a new style element or use an existing one\n    // and cache it internally\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n\n    /* istanbul ignore next */\n    if (!style.parentNode) document.head.appendChild(style);\n\n    return style\n  }\n})();\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nconst cssManager = {\n  CSS_BY_NAME,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this\n  },\n};\n\nexport { CSS_BY_NAME, STYLE_NODE_SELECTOR, cssManager as default };\n", "/* Riot WIP, @license MIT */\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn, ...acc) {\n  return (...args) => {\n    args = [...acc, ...args];\n\n    return args.length < fn.length ?\n      curry(fn, ...args) :\n      fn(...args)\n  }\n}\n\nexport { curry as default };\n", "/* Riot v9.1.8, @license MIT */\nimport { IS_DIRECTIVE } from '../dependencies/@riotjs/util/constants.js';\nimport { get } from '../dependencies/bianco.attr/index.next.js';\n\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase()\n}\n\nexport { getName };\n", "/* Riot v9.1.8, @license MIT */\nimport { IS_DIRECTIVE } from '../dependencies/@riotjs/util/constants.js';\nimport { getName } from '../utils/dom.js';\nimport { set } from '../dependencies/bianco.attr/index.next.js';\n\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, IS_DIRECTIVE, name);\n  }\n}\n\nexport { addCssHook };\n", "/* Riot v9.1.8, @license MIT */\nimport { callOrAssign } from '../dependencies/@riotjs/util/functions.js';\n\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state given to the `update` call\n * @returns {Object} new object state\n */\nfunction computeComponentState(oldState, newState) {\n  return {\n    ...oldState,\n    ...callOrAssign(newState),\n  }\n}\n\nexport { computeComponentState };\n", "/* Riot v9.1.8, @license MIT */\nimport { DOMattributesToObject } from '../dependencies/@riotjs/util/dom.js';\nimport { callOrAssign } from '../dependencies/@riotjs/util/functions.js';\n\n/**\n * Evaluate the component properties either from its real attributes or from its initial user properties\n * @param   {HTMLElement} element - component root\n * @param   {Object}  initialProps - initial props\n * @returns {Object} component props key value pairs\n */\nfunction computeInitialProps(element, initialProps = {}) {\n  return {\n    ...DOMattributesToObject(element),\n    ...callOrAssign(initialProps),\n  }\n}\n\nexport { computeInitialProps };\n", "/* Riot v9.1.8, @license MIT */\nimport { createCoreAPIMethods } from './create-core-api-methods.js';\nimport { createExpression as create$4 } from '../dependencies/@riotjs/dom-bindings/dist/dom-bindings.js';\n\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\nfunction createAttributeBindings(node, attributes = []) {\n  const expressions = attributes.map((a) => create$4(node, a));\n  const binding = {};\n\n  return Object.assign(binding, {\n    expressions,\n    ...createCoreAPIMethods((method) => (scope) => {\n      expressions.forEach((e) => e[method](scope));\n\n      return binding\n    }),\n  })\n}\n\nexport { createAttributeBindings };\n", "/* Riot v9.1.8, @license MIT */\nimport { PLUGINS_SET } from '../dependencies/@riotjs/util/constants.js';\n\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\nfunction runPlugins(component) {\n  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component)\n}\n\nexport { runPlugins };\n", "/* Riot v9.1.8, @license MIT */\nimport '../dependencies/@riotjs/dom-bindings/dist/dom-bindings.js';\nimport expressionTypes from '../dependencies/@riotjs/util/expression-types.js';\nimport { memoize } from '../dependencies/@riotjs/util/misc.js';\n\n/**\n * Get the computed attribute names from the template instance\n * Since these attributes will not change we memoize the result of this computation\n * @param {TemplateChunk} template - template instance\n * @return {[]} list of attribute names that will be computed by the template expressions\n */\nconst getRootComputedAttributeNames = memoize((template) => {\n  const firstBinding = template?.bindingsData?.[0];\n\n  // if the first binding has the selector attribute it means that it doesn't belong to the root node\n  if (firstBinding?.selector) return []\n\n  return (\n    firstBinding?.expressions?.reduce(\n      (acc, { name, type }) =>\n        type === expressionTypes.ATTRIBUTE ? acc.concat([name]) : acc,\n      [],\n    ) ?? []\n  )\n});\n\nexport { getRootComputedAttributeNames };\n", "/* Riot v9.1.8, @license MIT */\nimport { isFunction, isObject } from '../dependencies/@riotjs/util/checks.js';\nimport { IS_PURE_SYMBOL, PARENT_KEY_SYMBOL, ATTRIBUTES_KEY_SYMBOL, PROPS_KEY, STATE_KEY, TEMPLATE_KEY_SYMBOL, ROOT_KEY, SLOTS_KEY, ON_BEFORE_MOUNT_KEY, ON_MOUNTED_KEY, SHOULD_UPDATE_KEY, ON_BEFORE_UPDATE_KEY, IS_COMPONENT_UPDATING, ON_UPDATED_KEY, ON_BEFORE_UNMOUNT_KEY, ON_UNMOUNTED_KEY, IS_DIRECTIVE } from '../dependencies/@riotjs/util/constants.js';\nimport { DOMattributesToObject } from '../dependencies/@riotjs/util/dom.js';\nimport { autobindMethods } from '../dependencies/@riotjs/util/functions.js';\nimport { evaluateAttributeExpressions } from '../dependencies/@riotjs/util/misc.js';\nimport { defineProperties, defineProperty, pick } from '../dependencies/@riotjs/util/objects.js';\nimport { addCssHook } from './add-css-hook.js';\nimport { bindDOMNodeToComponentInstance } from './bind-dom-node-to-component-instance.js';\nimport { computeComponentState } from './compute-component-state.js';\nimport { computeInitialProps } from './compute-initial-props.js';\nimport { createAttributeBindings } from './create-attribute-bindings.js';\nimport { runPlugins } from './run-plugins.js';\nimport { getRootComputedAttributeNames } from '../utils/get-root-computed-attribute-names.js';\n\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\nfunction manageComponentLifecycle(\n  component,\n  { slots, attributes, props },\n) {\n  return autobindMethods(\n    runPlugins(\n      defineProperties(\n        isObject(component) ? Object.create(component) : component,\n        {\n          mount(element, state = {}, parentScope) {\n            // any element mounted passing through this function can't be a pure component\n            defineProperty(element, IS_PURE_SYMBOL, false);\n            this[PARENT_KEY_SYMBOL] = parentScope;\n            this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(\n              element,\n              attributes,\n            ).mount(parentScope);\n\n            defineProperty(\n              this,\n              PROPS_KEY,\n              Object.freeze({\n                ...computeInitialProps(element, props),\n                ...evaluateAttributeExpressions(\n                  this[ATTRIBUTES_KEY_SYMBOL].expressions,\n                ),\n              }),\n            );\n\n            this[STATE_KEY] = computeComponentState(this[STATE_KEY], state);\n            this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone();\n\n            // link this object to the DOM node\n            bindDOMNodeToComponentInstance(element, this);\n            // add eventually the 'is' attribute\n            component.name && addCssHook(element, component.name);\n\n            // define the root element\n            defineProperty(this, ROOT_KEY, element);\n            // define the slots array\n            defineProperty(this, SLOTS_KEY, slots);\n\n            // before mount lifecycle event\n            this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n            // mount the template\n            this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n            this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n\n            return this\n          },\n          update(state = {}, parentScope) {\n            if (parentScope) {\n              this[PARENT_KEY_SYMBOL] = parentScope;\n              this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n            }\n\n            // get the attribute names that don't belong to the the props object\n            // this will avoid recursive props rendering https://github.com/riot/riot/issues/2994\n            const computedAttributeNames = getRootComputedAttributeNames(\n              this[TEMPLATE_KEY_SYMBOL],\n            );\n            // filter out the computed attributes from the root node\n            const staticRootAttributes = Array.from(\n              this[ROOT_KEY].attributes,\n            ).filter(({ name }) => !computedAttributeNames.includes(name));\n\n            // evaluate the value of the static dom attributes\n            const domNodeAttributes = DOMattributesToObject({\n              attributes: staticRootAttributes,\n            });\n\n            // Avoid adding the riot \"is\" directives to the component props\n            // eslint-disable-next-line no-unused-vars\n            const { [IS_DIRECTIVE]: _, ...newProps } = {\n              ...domNodeAttributes,\n              ...evaluateAttributeExpressions(\n                this[ATTRIBUTES_KEY_SYMBOL].expressions,\n              ),\n            };\n            if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false)\n              return\n\n            defineProperty(\n              this,\n              PROPS_KEY,\n              Object.freeze({\n                // only root components will merge their initial props with the new ones\n                // children components will just get them overridden see also https://github.com/riot/riot/issues/2978\n                ...(parentScope\n                  ? pick(this[PROPS_KEY], computedAttributeNames)\n                  : this[PROPS_KEY]),\n                ...newProps,\n              }),\n            );\n\n            this[STATE_KEY] = computeComponentState(this[STATE_KEY], state);\n\n            this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]);\n\n            // avoiding recursive updates\n            // see also https://github.com/riot/riot/issues/2895\n            if (!this[IS_COMPONENT_UPDATING]) {\n              this[IS_COMPONENT_UPDATING] = true;\n              this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);\n            }\n\n            this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n            this[IS_COMPONENT_UPDATING] = false;\n\n            return this\n          },\n          unmount(preserveRoot) {\n            this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n            this[ATTRIBUTES_KEY_SYMBOL].unmount();\n            // if the preserveRoot is null the template html will be left untouched\n            // in that case the DOM cleanup will happen differently from a parent node\n            this[TEMPLATE_KEY_SYMBOL].unmount(\n              this,\n              this[PARENT_KEY_SYMBOL],\n              preserveRoot === null ? null : !preserveRoot,\n            );\n            this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n\n            return this\n          },\n        },\n      ),\n    ),\n    Object.keys(component).filter((prop) => isFunction(component[prop])),\n  )\n}\n\nexport { manageComponentLifecycle };\n", "/* Riot v9.1.8, @license MIT */\nimport { SLOTS_KEY, ROOT_KEY, PROPS_KEY, STATE_KEY } from '../dependencies/@riotjs/util/constants.js';\nimport { defineProperties, defineDefaults } from '../dependencies/@riotjs/util/objects.js';\nimport { COMPONENT_DOM_SELECTORS } from './component-dom-selectors.js';\nimport { COMPONENT_LIFECYCLE_METHODS } from './component-lifecycle-methods.js';\nimport cssManager from './css-manager.js';\nimport curry from '../dependencies/curri/index.js';\nimport { manageComponentLifecycle } from './manage-component-lifecycle.js';\n\n/**\n * Component definition function\n * @param   {Object} implementation - the component implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\nfunction instantiateComponent({ css, template, componentAPI, name }) {\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n\n  return curry(manageComponentLifecycle)(\n    defineProperties(\n      // set the component defaults without overriding the original component API\n      defineDefaults(componentAPI, {\n        ...COMPONENT_LIFECYCLE_METHODS,\n        [PROPS_KEY]: {},\n        [STATE_KEY]: {},\n      }),\n      {\n        // defined during the component creation\n        [SLOTS_KEY]: null,\n        [ROOT_KEY]: null,\n        // these properties should not be overriden\n        ...COMPONENT_DOM_SELECTORS,\n        name,\n        css,\n        template,\n      },\n    ),\n  )\n}\n\nexport { instantiateComponent };\n", "/* Riot v9.1.8, @license MIT */\nimport { IS_PURE_SYMBOL, COMPONENTS_IMPLEMENTATION_MAP } from '../dependencies/@riotjs/util/constants.js';\nimport { camelToDashCase } from '../dependencies/@riotjs/util/strings.js';\nimport { callOrAssign } from '../dependencies/@riotjs/util/functions.js';\nimport { memoize } from '../dependencies/@riotjs/util/misc.js';\nimport { MOCKED_TEMPLATE_INTERFACE } from './mocked-template-interface.js';\nimport { componentTemplateFactory } from './component-template-factory.js';\nimport { createPureComponent } from './create-pure-component.js';\nimport { instantiateComponent } from './instantiate-component.js';\n\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\nfunction createChildrenComponentsObject(components = {}) {\n  return Object.entries(callOrAssign(components)).reduce(\n    (acc, [key, value]) => {\n      acc[camelToDashCase(key)] = createComponentFromWrapper(value);\n      return acc\n    },\n    {},\n  )\n}\n\n/**\n * Create the getter function to render the child components\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {Function} function returning the component factory function\n */\nconst createChildComponentGetter = (componentWrapper) => {\n  const childrenComponents = createChildrenComponentsObject(\n    componentWrapper.exports ? componentWrapper.exports.components : {},\n  );\n\n  return (name) => {\n    // improve support for recursive components\n    if (name === componentWrapper.name)\n      return memoizedCreateComponentFromWrapper(componentWrapper)\n    // return the registered components\n    return childrenComponents[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name)\n  }\n};\n\n/**\n * Performance optimization for the recursive components\n * @param  {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {Object} component like interface\n */\nconst memoizedCreateComponentFromWrapper = memoize(createComponentFromWrapper);\n\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @param   {string} componentWrapper.css - component css\n * @param   {Function} componentWrapper.template - function that will return the dom-bindings template function\n * @param   {Object} componentWrapper.exports - component interface\n * @param   {string} componentWrapper.name - component name\n * @returns {Object} component like interface\n */\nfunction createComponentFromWrapper(componentWrapper) {\n  const { css, template, exports, name } = componentWrapper;\n  const templateFn = template\n    ? componentTemplateFactory(\n        template,\n        componentWrapper,\n        createChildComponentGetter(componentWrapper),\n      )\n    : MOCKED_TEMPLATE_INTERFACE;\n\n  return ({ slots, attributes, props }) => {\n    // pure components rendering will be managed by the end user\n    if (exports && exports[IS_PURE_SYMBOL])\n      return createPureComponent(exports, {\n        slots,\n        attributes,\n        props,\n        css,\n        template,\n      })\n\n    const componentAPI = callOrAssign(exports) || {};\n\n    const component = instantiateComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name,\n    })({ slots, attributes, props });\n\n    // notice that for the components created via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope)\n      },\n      update(parentScope, state) {\n        return component.update(state, parentScope)\n      },\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot)\n      },\n    }\n  }\n}\n\nexport { createComponentFromWrapper };\n", "/* Riot v9.1.8, @license MIT */\nimport { COMPONENTS_IMPLEMENTATION_MAP } from '../dependencies/@riotjs/util/constants.js';\nimport { panic } from '../dependencies/@riotjs/util/misc.js';\nimport { createComponentFromWrapper } from '../core/create-component-from-wrapper.js';\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\nfunction register(name, { css, template, exports }) {\n  if (COMPONENTS_IMPLEMENTATION_MAP.has(name))\n    panic(`The component \"${name}\" was already registered`);\n\n  COMPONENTS_IMPLEMENTATION_MAP.set(\n    name,\n    createComponentFromWrapper({ name, css, template, exports }),\n  );\n\n  return COMPONENTS_IMPLEMENTATION_MAP\n}\n\nexport { register };\n", "/* Riot v9.1.8, @license MIT */\nimport { COMPONENTS_IMPLEMENTATION_MAP } from '../dependencies/@riotjs/util/constants.js';\nimport { panic } from '../dependencies/@riotjs/util/misc.js';\nimport cssManager from '../core/css-manager.js';\n\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name))\n    panic(`The component \"${name}\" was never registered`);\n\n  COMPONENTS_IMPLEMENTATION_MAP.delete(name);\n  cssManager.remove(name);\n\n  return COMPONENTS_IMPLEMENTATION_MAP\n}\n\nexport { unregister };\n", "/* Riot v9.1.8, @license MIT */\nimport { COMPONENTS_IMPLEMENTATION_MAP } from '../dependencies/@riotjs/util/constants.js';\nimport { panic } from '../dependencies/@riotjs/util/misc.js';\nimport { getName } from '../utils/dom.js';\n\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @param   {Array} slots - component slots\n * @returns {Object} a new component instance bound to a DOM node\n */\nfunction mountComponent(element, initialProps, componentName, slots) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name))\n    panic(`The component named \"${name}\" was never registered`);\n\n  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({\n    props: initialProps,\n    slots,\n  });\n\n  return component.mount(element)\n}\n\nexport { mountComponent };\n", "/* Riot v9.1.8, @license MIT */\nimport $ from '../dependencies/bianco.query/index.next.js';\nimport { mountComponent } from '../core/mount-component.js';\n\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of riot components\n */\nfunction mount(selector, initialProps, name) {\n  return $(selector).map((element) =>\n    mountComponent(element, initialProps, name),\n  )\n}\n\nexport { mount };\n", "/* Riot v9.1.8, @license MIT */\nimport $ from '../dependencies/bianco.query/index.next.js';\nimport { DOM_COMPONENT_INSTANCE_PROPERTY } from '../dependencies/@riotjs/util/constants.js';\n\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {boolean|null} keepRootElement - if true keep the root element\n * @returns {Array} list of nodes unmounted\n */\nfunction unmount(selector, keepRootElement) {\n  return $(selector).map((element) => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY].unmount(keepRootElement);\n    }\n    return element\n  })\n}\n\nexport { unmount };\n", "/* Riot v9.1.8, @license MIT */\nimport { isFunction } from '../dependencies/@riotjs/util/checks.js';\nimport { PLUGINS_SET } from '../dependencies/@riotjs/util/constants.js';\nimport { panic } from '../dependencies/@riotjs/util/misc.js';\n\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET.has(plugin)) panic('This plugin was already installed');\n\n  PLUGINS_SET.add(plugin);\n\n  return PLUGINS_SET\n}\n\nexport { install };\n", "/* Riot v9.1.8, @license MIT */\nimport { PLUGINS_SET } from '../dependencies/@riotjs/util/constants.js';\nimport { panic } from '../dependencies/@riotjs/util/misc.js';\n\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET.has(plugin)) panic('This plugin was never installed');\n\n  PLUGINS_SET.delete(plugin);\n\n  return PLUGINS_SET\n}\n\nexport { uninstall };\n", "/* Riot WIP, @license MIT */\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\nfunction compose(...fns) {\n  return fns.reduce((f, g) => (...args) => f(g(...args)))\n}\n\nexport { compose as default };\n", "/* Riot v9.1.8, @license MIT */\nimport compose from '../dependencies/cumpa/index.js';\nimport { createComponentFromWrapper } from '../core/create-component-from-wrapper.js';\n\n/**\n * Helper method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\nfunction component(implementation) {\n  return (el, props, { slots, attributes, parentScope } = {}) =>\n    compose(\n      (c) => c.mount(el, parentScope),\n      (c) => c({ props, slots, attributes }),\n      createComponentFromWrapper,\n    )(implementation)\n}\n\nexport { component };\n", "/* Riot v9.1.8, @license MIT */\nimport { isFunction } from '../dependencies/@riotjs/util/checks.js';\nimport { IS_PURE_SYMBOL } from '../dependencies/@riotjs/util/constants.js';\nimport { panic } from '../dependencies/@riotjs/util/misc.js';\n\n/**\n * Lift a riot component Interface into a pure riot object\n * @param   {Function} func - RiotPureComponent factory function\n * @returns {Function} the lifted original function received as argument\n */\nfunction pure(func) {\n  if (!isFunction(func))\n    panic('riot.pure accepts only arguments of type \"function\"');\n  func[IS_PURE_SYMBOL] = true;\n  return func\n}\n\nexport { pure };\n", "/* Riot v9.1.8, @license MIT */\n/**\n * no-op function needed to add the proper types to your component via typescript\n * @param {Function|Object} component - component default export\n * @returns {Function|Object} returns exactly what it has received\n */\n/* istanbul ignore next */\nconst withTypes = (component) => component;\n\nexport { withTypes };\n", "/* Riot v9.1.8, @license MIT */\n/** @type {string} current riot version */\nconst version = 'v9.1.8';\n\nexport { version };\n", "/* Riot v9.1.8, @license MIT */\nimport bindingTypes from '../dependencies/@riotjs/util/binding-types.js';\nimport { PROPS_KEY, STATE_KEY, IS_COMPONENT_UPDATING, ATTRIBUTES_KEY_SYMBOL, COMPONENTS_IMPLEMENTATION_MAP, PLUGINS_SET, DOM_COMPONENT_INSTANCE_PROPERTY, PARENT_KEY_SYMBOL } from '../dependencies/@riotjs/util/constants.js';\nimport expressionTypes from '../dependencies/@riotjs/util/expression-types.js';\nimport { template as create, createBinding as create$1, createExpression as create$4 } from '../dependencies/@riotjs/dom-bindings/dist/dom-bindings.js';\nimport cssManager from '../core/css-manager.js';\n\n// expose some internal stuff that might be used from external tools\nconst __ = {\n  cssManager,\n  DOMBindings: {\n    template: create,\n    createBinding: create$1,\n    createExpression: create$4,\n    bindingTypes,\n    expressionTypes,\n  },\n  globals: {\n    PROPS_KEY,\n    STATE_KEY,\n    IS_COMPONENT_UPDATING,\n    ATTRIBUTES_KEY_SYMBOL,\n    COMPONENTS_IMPLEMENTATION_MAP,\n    PLUGINS_SET,\n    DOM_COMPONENT_INSTANCE_PROPERTY,\n    PARENT_KEY_SYMBOL,\n  },\n};\n\nexport { __ };\n"],
  "mappings": "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",
  "names": ["__", "get", "mount", "isBoolean", "expressions", "component", "bindings", "component", "component", "expressions", "component", "component", "component", "component", "component"]
}
