// node_modules/riot/esm/dependencies/@riotjs/util/constants.js
var COMPONENTS_IMPLEMENTATION_MAP = /* @__PURE__ */ new Map();
var DOM_COMPONENT_INSTANCE_PROPERTY = Symbol("riot-component");
var PLUGINS_SET = /* @__PURE__ */ new Set();
var IS_DIRECTIVE = "is";
var MOUNT_METHOD_KEY = "mount";
var UPDATE_METHOD_KEY = "update";
var UNMOUNT_METHOD_KEY = "unmount";
var SHOULD_UPDATE_KEY = "shouldUpdate";
var ON_BEFORE_MOUNT_KEY = "onBeforeMount";
var ON_MOUNTED_KEY = "onMounted";
var ON_BEFORE_UPDATE_KEY = "onBeforeUpdate";
var ON_UPDATED_KEY = "onUpdated";
var ON_BEFORE_UNMOUNT_KEY = "onBeforeUnmount";
var ON_UNMOUNTED_KEY = "onUnmounted";
var PROPS_KEY = "props";
var STATE_KEY = "state";
var SLOTS_KEY = "slots";
var ROOT_KEY = "root";
var IS_PURE_SYMBOL = Symbol("pure");
var IS_COMPONENT_UPDATING = Symbol("is_updating");
var PARENT_KEY_SYMBOL = Symbol("parent");
var ATTRIBUTES_KEY_SYMBOL = Symbol("attributes");
var TEMPLATE_KEY_SYMBOL = Symbol("template");

// node_modules/riot/esm/dependencies/@riotjs/util/expression-types.js
var ATTRIBUTE = 0;
var EVENT = 1;
var TEXT = 2;
var VALUE = 3;
var expressionTypes = {
  ATTRIBUTE,
  EVENT,
  TEXT,
  VALUE
};

// node_modules/riot/esm/dependencies/@riotjs/util/strings.js
function camelToDashCase(string) {
  return string.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function dashToCamelCase(string) {
  return string.replace(/-(\w)/g, (_, c) => c.toUpperCase());
}

// node_modules/riot/esm/dependencies/@riotjs/util/misc.js
function panic(message, cause) {
  throw new Error(message, { cause });
}
function memoize(fn) {
  const cache = /* @__PURE__ */ new Map();
  const cached = (val) => {
    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);
  };
  cached.cache = cache;
  return cached;
}
function evaluateAttributeExpressions(attributes) {
  return attributes.reduce((acc, attribute) => {
    const { value, type } = attribute;
    switch (true) {
      case (!attribute.name && type === ATTRIBUTE):
        return {
          ...acc,
          ...value
        };
      case type === VALUE:
        acc.value = attribute.value;
        break;
      default:
        acc[dashToCamelCase(attribute.name)] = attribute.value;
    }
    return acc;
  }, {});
}

// node_modules/riot/esm/dependencies/@riotjs/util/checks.js
function checkType(element, type) {
  return typeof element === type;
}
function isSvg(el) {
  const owner = el.ownerSVGElement;
  return !!owner || owner === null;
}
function isTemplate(el) {
  return el.tagName.toLowerCase() === "template";
}
function isFunction(value) {
  return checkType(value, "function");
}
function isBoolean(value) {
  return checkType(value, "boolean");
}
function isObject(value) {
  return !isNil(value) && value.constructor === Object;
}
function isNil(value) {
  return value === null || value === void 0;
}

// node_modules/riot/esm/dependencies/@riotjs/util/functions.js
function noop() {
  return this;
}
function autobindMethods(source, methods) {
  methods.forEach((method) => {
    source[method] = source[method].bind(source);
  });
  return source;
}
function callOrAssign(source) {
  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;
}

// node_modules/riot/esm/dependencies/@riotjs/util/dom.js
function DOMattributesToObject(element) {
  return Array.from(element.attributes).reduce((acc, attribute) => {
    acc[dashToCamelCase(attribute.name)] = attribute.value;
    return acc;
  }, {});
}
function moveChildren(source, target) {
  while (source.firstChild) target.appendChild(source.firstChild);
}
function cleanNode(node) {
  while (node.firstChild) node.removeChild(node.firstChild);
}
function clearChildren(children) {
  for (let i = 0; i < children.length; i++) removeChild(children[i]);
}
var removeChild = (node) => node.remove();
var insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode);
var replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced);

// node_modules/riot/esm/core/mocked-template-interface.js
var MOCKED_TEMPLATE_INTERFACE = {
  [MOUNT_METHOD_KEY](el) {
    this.el = el;
  },
  [UPDATE_METHOD_KEY]: noop,
  [UNMOUNT_METHOD_KEY](_, __2, mustRemoveRoot = false) {
    if (mustRemoveRoot) removeChild(this.el);
    else if (!mustRemoveRoot) cleanNode(this.el);
  },
  clone: noop,
  createDOM: noop
};

// node_modules/riot/esm/dependencies/@riotjs/util/binding-types.js
var EACH = 0;
var IF = 1;
var SIMPLE = 2;
var TAG = 3;
var SLOT = 4;
var bindingTypes = {
  EACH,
  IF,
  SIMPLE,
  TAG,
  SLOT
};

// node_modules/riot/esm/dependencies/@riotjs/util/objects.js
function defineProperty(source, key, value, options = {}) {
  Object.defineProperty(source, key, {
    value,
    enumerable: false,
    writable: false,
    configurable: true,
    ...options
  });
  return source;
}
function defineProperties(source, properties, options) {
  Object.entries(properties).forEach(([key, value]) => {
    defineProperty(source, key, value, options);
  });
  return source;
}
function defineDefaults(source, defaults) {
  Object.entries(defaults).forEach(([key, value]) => {
    if (!source[key]) source[key] = value;
  });
  return source;
}
function pick(source, keys) {
  return isObject(source) ? Object.fromEntries(keys.map((key) => [key, source[key]])) : source;
}

// node_modules/riot/esm/dependencies/@riotjs/dom-bindings/dist/dom-bindings.js
var HEAD_SYMBOL = Symbol();
var TAIL_SYMBOL = Symbol();
function createHeadTailPlaceholders() {
  const head = document.createTextNode("");
  const tail = document.createTextNode("");
  head[HEAD_SYMBOL] = true;
  tail[TAIL_SYMBOL] = true;
  return { head, tail };
}
function createTemplateMeta(componentTemplate) {
  const fragment = componentTemplate.dom.cloneNode(true);
  const { head, tail } = createHeadTailPlaceholders();
  return {
    avoidDOMInjection: true,
    fragment,
    head,
    tail,
    children: [head, ...Array.from(fragment.childNodes), tail]
  };
}
var udomdiff = (a, b, get2, before) => {
  const bLength = b.length;
  let aEnd = a.length;
  let bEnd = bLength;
  let aStart = 0;
  let bStart = 0;
  let map = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (aEnd === aStart) {
      const node = bEnd < bLength ? bStart ? get2(b[bStart - 1], -0).nextSibling : get2(b[bEnd - bStart], 0) : before;
      while (bStart < bEnd) insertBefore(get2(b[bStart++], 1), node);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map || !map.has(a[aStart])) removeChild(get2(a[aStart], -1));
        aStart++;
      }
    } else if (a[aStart] === b[bStart]) {
      aStart++;
      bStart++;
    } else if (a[aEnd - 1] === b[bEnd - 1]) {
      aEnd--;
      bEnd--;
    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
      const node = get2(a[--aEnd], -1).nextSibling;
      insertBefore(get2(b[bStart++], 1), get2(a[aStart++], -1).nextSibling);
      insertBefore(get2(b[--bEnd], 1), node);
      a[aEnd] = b[bEnd];
    } else {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        let i = bStart;
        while (i < bEnd) map.set(b[i], i++);
      }
      if (map.has(a[aStart])) {
        const index = map.get(a[aStart]);
        if (bStart < index && index < bEnd) {
          let i = aStart;
          let sequence = 1;
          while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence)
            sequence++;
          if (sequence > index - bStart) {
            const node = get2(a[aStart], 0);
            while (bStart < index) insertBefore(get2(b[bStart++], 1), node);
          } else {
            replaceChild(get2(b[bStart++], 1), get2(a[aStart++], -1));
          }
        } else aStart++;
      } else removeChild(get2(a[aStart++], -1));
    }
  }
  return b;
};
var UNMOUNT_SCOPE = Symbol("unmount");
var EachBinding = {
  // dynamic binding properties
  // childrenMap: null,
  // node: null,
  // root: null,
  // condition: null,
  // evaluate: null,
  // template: null,
  // isTemplateTag: false,
  nodes: [],
  // getKey: null,
  // indexName: null,
  // itemName: null,
  // afterPlaceholder: null,
  // placeholder: null,
  // API methods
  mount(scope, parentScope) {
    return this.update(scope, parentScope);
  },
  update(scope, parentScope) {
    const { placeholder, nodes, childrenMap } = this;
    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);
    const items = collection ? Array.from(collection) : [];
    const { newChildrenMap, batches, futureNodes } = createPatch(
      items,
      scope,
      parentScope,
      this
    );
    udomdiff(
      nodes,
      futureNodes,
      patch(Array.from(childrenMap.values()), parentScope),
      placeholder
    );
    batches.forEach((fn) => fn());
    this.childrenMap = newChildrenMap;
    this.nodes = futureNodes;
    return this;
  },
  unmount(scope, parentScope) {
    this.update(UNMOUNT_SCOPE, parentScope);
    return this;
  }
};
function patch(redundant, parentScope) {
  return (item, info) => {
    if (info < 0) {
      const element = redundant[redundant.length - 1];
      if (element) {
        const { template, nodes, context } = element;
        nodes.pop();
        if (!nodes.length) {
          redundant.pop();
          template.unmount(context, parentScope, null);
        }
      }
    }
    return item;
  };
}
function mustFilterItem(condition, context) {
  return condition ? !condition(context) : false;
}
function extendScope(scope, { itemName, indexName, index, item }) {
  defineProperty(scope, itemName, item);
  if (indexName) defineProperty(scope, indexName, index);
  return scope;
}
function createPatch(items, scope, parentScope, binding) {
  const {
    condition,
    template,
    childrenMap,
    itemName,
    getKey,
    indexName,
    root,
    isTemplateTag
  } = binding;
  const newChildrenMap = /* @__PURE__ */ new Map();
  const batches = [];
  const futureNodes = [];
  items.forEach((item, index) => {
    const context = extendScope(Object.create(scope), {
      itemName,
      indexName,
      index,
      item
    });
    const key = getKey ? getKey(context) : index;
    const oldItem = childrenMap.get(key);
    const nodes = [];
    if (mustFilterItem(condition, context)) {
      return;
    }
    const mustMount = !oldItem;
    const componentTemplate = oldItem ? oldItem.template : template.clone();
    const el = componentTemplate.el || root.cloneNode();
    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : componentTemplate.meta;
    if (mustMount) {
      batches.push(
        () => componentTemplate.mount(el, context, parentScope, meta)
      );
    } else {
      batches.push(() => componentTemplate.update(context, parentScope));
    }
    if (isTemplateTag) {
      nodes.push(...meta.children);
    } else {
      nodes.push(el);
    }
    childrenMap.delete(key);
    futureNodes.push(...nodes);
    newChildrenMap.set(key, {
      nodes,
      template: componentTemplate,
      context,
      index
    });
  });
  return {
    newChildrenMap,
    batches,
    futureNodes
  };
}
function create$6(node, { evaluate, condition, itemName, indexName, getKey, template }) {
  const placeholder = document.createTextNode("");
  const root = node.cloneNode();
  insertBefore(placeholder, node);
  removeChild(node);
  return {
    ...EachBinding,
    childrenMap: /* @__PURE__ */ new Map(),
    node,
    root,
    condition,
    evaluate,
    isTemplateTag: isTemplate(root),
    template: template.createDOM(node),
    getKey,
    indexName,
    itemName,
    placeholder
  };
}
var IfBinding = {
  // dynamic binding properties
  // node: null,
  // evaluate: null,
  // isTemplateTag: false,
  // placeholder: null,
  // template: null,
  // API methods
  mount(scope, parentScope) {
    return this.update(scope, parentScope);
  },
  update(scope, parentScope) {
    const value = !!this.evaluate(scope);
    const mustMount = !this.value && value;
    const mustUnmount = this.value && !value;
    const mount2 = () => {
      const pristine = this.node.cloneNode();
      insertBefore(pristine, this.placeholder);
      this.template = this.template.clone();
      this.template.mount(pristine, scope, parentScope);
    };
    switch (true) {
      case mustMount:
        mount2();
        break;
      case mustUnmount:
        this.unmount(scope);
        break;
      default:
        if (value) this.template.update(scope, parentScope);
    }
    this.value = value;
    return this;
  },
  unmount(scope, parentScope) {
    this.template.unmount(scope, parentScope, true);
    return this;
  }
};
function create$5(node, { evaluate, template }) {
  const placeholder = document.createTextNode("");
  insertBefore(placeholder, node);
  removeChild(node);
  return {
    ...IfBinding,
    node,
    evaluate,
    placeholder,
    template: template.createDOM(node)
  };
}
var ElementProto = typeof Element === "undefined" ? {} : Element.prototype;
var isNativeHtmlProperty = memoize(
  (name) => ElementProto.hasOwnProperty(name)
  // eslint-disable-line
);
function setAllAttributes(node, attributes) {
  Object.keys(attributes).forEach(
    (name) => attributeExpression(node, { name }, attributes[name])
  );
}
function removeAllAttributes(node, newAttributes, oldAttributes) {
  const newKeys = newAttributes ? Object.keys(newAttributes) : [];
  Object.keys(oldAttributes).filter((name) => !newKeys.includes(name)).forEach((attribute) => node.removeAttribute(attribute));
}
function canRenderAttribute(value) {
  return ["string", "number", "boolean"].includes(typeof value);
}
function shouldRemoveAttribute(value, isBoolean2) {
  if (isBoolean2) return !value && value !== 0;
  return typeof value === "undefined" || value === null;
}
function attributeExpression(node, { name, isBoolean: isBoolean$1 }, value, oldValue) {
  if (!name) {
    if (oldValue) {
      removeAllAttributes(node, value, oldValue);
    }
    if (value) {
      setAllAttributes(node, value);
    }
    return;
  }
  if (!isNativeHtmlProperty(name) && (isBoolean(value) || isObject(value) || isFunction(value))) {
    node[name] = value;
  }
  if (shouldRemoveAttribute(value, isBoolean$1)) {
    node.removeAttribute(name);
  } else if (canRenderAttribute(value)) {
    node.setAttribute(name, normalizeValue(name, value, isBoolean$1));
  }
}
function normalizeValue(name, value, isBoolean2) {
  return value === true && isBoolean2 ? name : value;
}
var RE_EVENTS_PREFIX = /^on/;
var getCallbackAndOptions = (value) => Array.isArray(value) ? value : [value, false];
var EventListener = {
  handleEvent(event) {
    this[event.type](event);
  }
};
var ListenersWeakMap = /* @__PURE__ */ new WeakMap();
var createListener = (node) => {
  const listener = Object.create(EventListener);
  ListenersWeakMap.set(node, listener);
  return listener;
};
function eventExpression(node, { name }, value) {
  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, "");
  const eventListener = ListenersWeakMap.get(node) || createListener(node);
  const [callback, options] = getCallbackAndOptions(value);
  const handler = eventListener[normalizedEventName];
  const mustRemoveEvent = handler && !callback;
  const mustAddEvent = callback && !handler;
  if (mustRemoveEvent) {
    node.removeEventListener(normalizedEventName, eventListener);
  }
  if (mustAddEvent) {
    node.addEventListener(normalizedEventName, eventListener, options);
  }
  eventListener[normalizedEventName] = callback;
}
function normalizeStringValue(value) {
  return isNil(value) ? "" : value;
}
var getTextNode = (node, childNodeIndex) => {
  return node.childNodes[childNodeIndex];
};
function textExpression(node, data, value) {
  node.data = normalizeStringValue(value);
}
function valueExpression(node, expression, value) {
  node.value = normalizeStringValue(value);
}
var expressions = {
  [ATTRIBUTE]: attributeExpression,
  [EVENT]: eventExpression,
  [TEXT]: textExpression,
  [VALUE]: valueExpression
};
var Expression = {
  // Static props
  // node: null,
  // value: null,
  // API methods
  /**
   * Mount the expression evaluating its initial value
   * @param   {*} scope - argument passed to the expression to evaluate its current values
   * @returns {Expression} self
   */
  mount(scope) {
    this.value = this.evaluate(scope);
    apply(this, this.value);
    return this;
  },
  /**
   * Update the expression if its value changed
   * @param   {*} scope - argument passed to the expression to evaluate its current values
   * @returns {Expression} self
   */
  update(scope) {
    const value = this.evaluate(scope);
    if (this.value !== value) {
      apply(this, value);
      this.value = value;
    }
    return this;
  },
  /**
   * Expression teardown method
   * @returns {Expression} self
   */
  unmount() {
    if (this.type === EVENT) apply(this, null);
    return this;
  }
};
function apply(expression, value) {
  return expressions[expression.type](
    expression.node,
    expression,
    value,
    expression.value
  );
}
function create$4(node, data) {
  return {
    ...Expression,
    ...data,
    node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node
  };
}
function flattenCollectionMethods(collection, methods, context) {
  return methods.reduce((acc, method) => {
    return {
      ...acc,
      [method]: (scope) => {
        return collection.map((item) => item[method](scope)) && context;
      }
    };
  }, {});
}
function create$3(node, { expressions: expressions2 }) {
  return flattenCollectionMethods(
    expressions2.map((expression) => create$4(node, expression)),
    ["mount", "update", "unmount"]
  );
}
function extendParentScope(attributes, scope, parentScope) {
  if (!attributes || !attributes.length) return parentScope;
  const expressions2 = attributes.map((attr) => ({
    ...attr,
    value: attr.evaluate(scope)
  }));
  return Object.assign(
    Object.create(parentScope || null),
    evaluateAttributeExpressions(expressions2)
  );
}
var getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope;
var SlotBinding = {
  // dynamic binding properties
  // node: null,
  // name: null,
  attributes: [],
  // template: null,
  getTemplateScope(scope, parentScope) {
    return extendParentScope(this.attributes, scope, parentScope);
  },
  // API methods
  mount(scope, parentScope) {
    const templateData = scope.slots ? scope.slots.find(({ id }) => id === this.name) : false;
    const { parentNode } = this.node;
    const realParent = getRealParent(scope, parentScope);
    this.template = templateData && create(templateData.html, templateData.bindings).createDOM(parentNode);
    if (this.template) {
      cleanNode(this.node);
      this.template.mount(
        this.node,
        this.getTemplateScope(scope, realParent),
        realParent
      );
      this.template.children = Array.from(this.node.childNodes);
    }
    moveSlotInnerContent(this.node);
    removeChild(this.node);
    return this;
  },
  update(scope, parentScope) {
    if (this.template) {
      const realParent = getRealParent(scope, parentScope);
      this.template.update(this.getTemplateScope(scope, realParent), realParent);
    }
    return this;
  },
  unmount(scope, parentScope, mustRemoveRoot) {
    if (this.template) {
      this.template.unmount(
        this.getTemplateScope(scope, parentScope),
        null,
        mustRemoveRoot
      );
    }
    return this;
  }
};
function moveSlotInnerContent(slot) {
  const child = slot && slot.firstChild;
  if (!child) return;
  insertBefore(child, slot);
  moveSlotInnerContent(slot);
}
function createSlot(node, { name, attributes }) {
  return {
    ...SlotBinding,
    attributes,
    node,
    name
  };
}
function getTag(component2, slots = [], attributes = []) {
  if (component2) {
    return component2({ slots, attributes });
  }
  return create(slotsToMarkup(slots), [
    ...slotBindings(slots),
    {
      // the attributes should be registered as binding
      // if we fallback to a normal template chunk
      expressions: attributes.map((attr) => {
        return {
          type: ATTRIBUTE,
          ...attr
        };
      })
    }
  ]);
}
function slotBindings(slots) {
  return slots.reduce((acc, { bindings: bindings2 }) => acc.concat(bindings2), []);
}
function slotsToMarkup(slots) {
  return slots.reduce((acc, slot) => {
    return acc + slot.html;
  }, "");
}
var TagBinding = {
  // dynamic binding properties
  // node: null,
  // evaluate: null,
  // name: null,
  // slots: null,
  // tag: null,
  // attributes: null,
  // getComponent: null,
  mount(scope) {
    return this.update(scope);
  },
  update(scope, parentScope) {
    const name = this.evaluate(scope);
    if (name && name === this.name) {
      this.tag.update(scope);
    } else {
      this.unmount(scope, parentScope, true);
      this.name = name;
      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);
      this.tag.mount(this.node, scope);
    }
    return this;
  },
  unmount(scope, parentScope, keepRootTag) {
    if (this.tag) {
      this.tag.unmount(keepRootTag);
    }
    return this;
  }
};
function create$2(node, { evaluate, getComponent, slots, attributes }) {
  return {
    ...TagBinding,
    node,
    evaluate,
    slots,
    attributes,
    getComponent
  };
}
var bindings = {
  [IF]: create$5,
  [SIMPLE]: create$3,
  [EACH]: create$6,
  [TAG]: create$2,
  [SLOT]: createSlot
};
function fixTextExpressionsOffset(expressions2, textExpressionsOffset) {
  return expressions2.map(
    (e) => e.type === TEXT ? {
      ...e,
      childNodeIndex: e.childNodeIndex + textExpressionsOffset
    } : e
  );
}
function create$1(root, binding, templateTagOffset) {
  const { selector, type, redundantAttribute, expressions: expressions2 } = binding;
  const node = selector ? root.querySelector(selector) : root;
  if (redundantAttribute) node.removeAttribute(redundantAttribute);
  const bindingExpressions = expressions2 || [];
  return (bindings[type] || bindings[SIMPLE])(node, {
    ...binding,
    expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions
  });
}
function createHTMLTree(html, root) {
  const template = isTemplate(root) ? root : document.createElement("template");
  template.innerHTML = html;
  return template.content;
}
function createSVGTree(html, container) {
  const svgNode = container.ownerDocument.importNode(
    new window.DOMParser().parseFromString(
      `<svg xmlns="http://www.w3.org/2000/svg">${html}</svg>`,
      "application/xml"
    ).documentElement,
    true
  );
  return svgNode;
}
function createDOMTree(root, html) {
  if (isSvg(root)) return createSVGTree(html, root);
  return createHTMLTree(html, root);
}
function injectDOM(el, dom) {
  switch (true) {
    case isSvg(el):
      moveChildren(dom, el);
      break;
    case isTemplate(el):
      el.parentNode.replaceChild(dom, el);
      break;
    default:
      el.appendChild(dom);
  }
}
function createTemplateDOM(el, html) {
  return html && (typeof html === "string" ? createDOMTree(el, html) : html);
}
function getTemplateTagOffset(parentNode, el, meta) {
  const siblings = Array.from(parentNode.childNodes);
  return Math.max(siblings.indexOf(el), siblings.indexOf(meta.head) + 1, 0);
}
var TemplateChunk = {
  // Static props
  // bindings: null,
  // bindingsData: null,
  // html: null,
  // isTemplateTag: false,
  // fragment: null,
  // children: null,
  // dom: null,
  // el: null,
  /**
   * Create the template DOM structure that will be cloned on each mount
   * @param   {HTMLElement} el - the root node
   * @returns {TemplateChunk} self
   */
  createDOM(el) {
    this.dom = this.dom || createTemplateDOM(el, this.html) || document.createDocumentFragment();
    return this;
  },
  // API methods
  /**
   * Attach the template to a DOM node
   * @param   {HTMLElement} el - target DOM node
   * @param   {*} scope - template data
   * @param   {*} parentScope - scope of the parent template tag
   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops
   * @returns {TemplateChunk} self
   */
  mount(el, scope, parentScope, meta = {}) {
    if (!el) panic("Please provide DOM node to mount properly your template");
    if (this.el) this.unmount(scope);
    const { fragment, children, avoidDOMInjection } = meta;
    const { parentNode } = children ? children[0] : el;
    const isTemplateTag = isTemplate(el);
    const templateTagOffset = isTemplateTag ? getTemplateTagOffset(parentNode, el, meta) : null;
    this.createDOM(el);
    const cloneNode = fragment || this.dom.cloneNode(true);
    this.el = isTemplateTag ? parentNode : el;
    this.children = isTemplateTag ? children || Array.from(cloneNode.childNodes) : null;
    if (!avoidDOMInjection && cloneNode) injectDOM(el, cloneNode);
    this.bindings = this.bindingsData.map(
      (binding) => create$1(this.el, binding, templateTagOffset)
    );
    this.bindings.forEach((b) => b.mount(scope, parentScope));
    this.meta = meta;
    return this;
  },
  /**
   * Update the template with fresh data
   * @param   {*} scope - template data
   * @param   {*} parentScope - scope of the parent template tag
   * @returns {TemplateChunk} self
   */
  update(scope, parentScope) {
    this.bindings.forEach((b) => b.update(scope, parentScope));
    return this;
  },
  /**
   * Remove the template from the node where it was initially mounted
   * @param   {*} scope - template data
   * @param   {*} parentScope - scope of the parent template tag
   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,
   * if false or undefined clean the root tag content, if null don't touch the DOM
   * @returns {TemplateChunk} self
   */
  unmount(scope, parentScope, mustRemoveRoot = false) {
    const el = this.el;
    if (!el) {
      return this;
    }
    this.bindings.forEach((b) => b.unmount(scope, parentScope, mustRemoveRoot));
    switch (true) {
      case (el[IS_PURE_SYMBOL] || mustRemoveRoot === null):
        break;
      case Array.isArray(this.children):
        clearChildren(this.children);
        break;
      case !mustRemoveRoot:
        cleanNode(el);
        break;
      case !!mustRemoveRoot:
        removeChild(el);
        break;
    }
    this.el = null;
    return this;
  },
  /**
   * Clone the template chunk
   * @returns {TemplateChunk} a clone of this object resetting the this.el property
   */
  clone() {
    return {
      ...this,
      meta: {},
      el: null
    };
  }
};
function create(html, bindings2 = []) {
  return {
    ...TemplateChunk,
    html,
    bindingsData: bindings2
  };
}

// node_modules/riot/esm/core/component-template-factory.js
function componentTemplateFactory(template, componentWrapper, getChildComponent) {
  return template(
    create,
    expressionTypes,
    bindingTypes,
    getChildComponent
  );
}

// node_modules/riot/esm/core/pure-component-api.js
var PURE_COMPONENT_API = Object.freeze({
  [MOUNT_METHOD_KEY]: noop,
  [UPDATE_METHOD_KEY]: noop,
  [UNMOUNT_METHOD_KEY]: noop
});

// node_modules/riot/esm/core/bind-dom-node-to-component-instance.js
var bindDOMNodeToComponentInstance = (node, component2) => node[DOM_COMPONENT_INSTANCE_PROPERTY] = component2;

// node_modules/riot/esm/core/create-core-api-methods.js
function createCoreAPIMethods(mapFunction) {
  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce(
    (acc, method) => {
      acc[method] = mapFunction(method);
      return acc;
    },
    {}
  );
}

// node_modules/riot/esm/core/create-pure-component.js
function createPureComponent(pureFactoryFunction, { slots, attributes, props, css, template }) {
  if (template) panic("Pure components can not have html");
  if (css) panic("Pure components do not have css");
  const component2 = defineDefaults(
    pureFactoryFunction({ slots, attributes, props }),
    PURE_COMPONENT_API
  );
  return createCoreAPIMethods((method) => (...args) => {
    if (method === MOUNT_METHOD_KEY) {
      const [element] = args;
      defineProperty(element, IS_PURE_SYMBOL, true);
      bindDOMNodeToComponentInstance(element, component2);
    }
    component2[method](...args);
    return component2;
  });
}

// node_modules/riot/esm/dependencies/bianco.dom-to-array/index.next.js
function domToArray(els) {
  if (!Array.isArray(els)) {
    if (/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === "number")
      return Array.from(els);
    else
      return [els];
  }
  return els;
}

// node_modules/riot/esm/dependencies/bianco.query/index.next.js
function $(selector, scope) {
  return domToArray(
    typeof selector === "string" ? (scope || document).querySelectorAll(selector) : selector
  );
}

// node_modules/riot/esm/core/component-dom-selectors.js
var COMPONENT_DOM_SELECTORS = Object.freeze({
  // component helpers
  $(selector) {
    return $(selector, this.root)[0];
  },
  $$(selector) {
    return $(selector, this.root);
  }
});

// node_modules/riot/esm/core/component-lifecycle-methods.js
var COMPONENT_LIFECYCLE_METHODS = Object.freeze({
  [SHOULD_UPDATE_KEY]: noop,
  [ON_BEFORE_MOUNT_KEY]: noop,
  [ON_MOUNTED_KEY]: noop,
  [ON_BEFORE_UPDATE_KEY]: noop,
  [ON_UPDATED_KEY]: noop,
  [ON_BEFORE_UNMOUNT_KEY]: noop,
  [ON_UNMOUNTED_KEY]: noop
});

// node_modules/riot/esm/dependencies/bianco.attr/index.next.js
var normalize = (values) => values.length === 1 ? values[0] : values;
function parseNodes(els, name, method) {
  const names = typeof name === "string" ? [name] : name;
  return normalize(domToArray(els).map((el) => {
    return normalize(names.map((n) => el[method](n)));
  }));
}
function set(els, name, value) {
  const attrs = typeof name === "object" ? name : { [name]: value };
  const props = Object.keys(attrs);
  domToArray(els).forEach((el) => {
    props.forEach((prop) => el.setAttribute(prop, attrs[prop]));
  });
  return els;
}
function get(els, name) {
  return parseNodes(els, name, "getAttribute");
}

// node_modules/riot/esm/core/css-manager.js
var CSS_BY_NAME = /* @__PURE__ */ new Map();
var STYLE_NODE_SELECTOR = "style[riot]";
var getStyleNode = /* @__PURE__ */ ((style) => {
  return () => {
    if (style) return style;
    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement("style");
    set(style, "type", "text/css");
    if (!style.parentNode) document.head.appendChild(style);
    return style;
  };
})();
var cssManager = {
  CSS_BY_NAME,
  /**
   * Save a tag style to be later injected into DOM
   * @param { string } name - if it's passed we will map the css to a tagname
   * @param { string } css - css string
   * @returns {Object} self
   */
  add(name, css) {
    if (!CSS_BY_NAME.has(name)) {
      CSS_BY_NAME.set(name, css);
      this.inject();
    }
    return this;
  },
  /**
   * Inject all previously saved tag styles into DOM
   * innerHTML seems slow: http://jsperf.com/riot-insert-style
   * @returns {Object} self
   */
  inject() {
    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join("\n");
    return this;
  },
  /**
   * Remove a tag style from the DOM
   * @param {string} name a registered tagname
   * @returns {Object} self
   */
  remove(name) {
    if (CSS_BY_NAME.has(name)) {
      CSS_BY_NAME.delete(name);
      this.inject();
    }
    return this;
  }
};

// node_modules/riot/esm/dependencies/curri/index.js
function curry(fn, ...acc) {
  return (...args) => {
    args = [...acc, ...args];
    return args.length < fn.length ? curry(fn, ...args) : fn(...args);
  };
}

// node_modules/riot/esm/utils/dom.js
function getName(element) {
  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();
}

// node_modules/riot/esm/core/add-css-hook.js
function addCssHook(element, name) {
  if (getName(element) !== name) {
    set(element, IS_DIRECTIVE, name);
  }
}

// node_modules/riot/esm/core/compute-component-state.js
function computeComponentState(oldState, newState) {
  return {
    ...oldState,
    ...callOrAssign(newState)
  };
}

// node_modules/riot/esm/core/compute-initial-props.js
function computeInitialProps(element, initialProps = {}) {
  return {
    ...DOMattributesToObject(element),
    ...callOrAssign(initialProps)
  };
}

// node_modules/riot/esm/core/create-attribute-bindings.js
function createAttributeBindings(node, attributes = []) {
  const expressions2 = attributes.map((a) => create$4(node, a));
  const binding = {};
  return Object.assign(binding, {
    expressions: expressions2,
    ...createCoreAPIMethods((method) => (scope) => {
      expressions2.forEach((e) => e[method](scope));
      return binding;
    })
  });
}

// node_modules/riot/esm/core/run-plugins.js
function runPlugins(component2) {
  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component2);
}

// node_modules/riot/esm/utils/get-root-computed-attribute-names.js
var getRootComputedAttributeNames = memoize((template) => {
  var _a, _b;
  const firstBinding = (_a = template == null ? void 0 : template.bindingsData) == null ? void 0 : _a[0];
  if (firstBinding == null ? void 0 : firstBinding.selector) return [];
  return ((_b = firstBinding == null ? void 0 : firstBinding.expressions) == null ? void 0 : _b.reduce(
    (acc, { name, type }) => type === expressionTypes.ATTRIBUTE ? acc.concat([name]) : acc,
    []
  )) ?? [];
});

// node_modules/riot/esm/core/manage-component-lifecycle.js
function manageComponentLifecycle(component2, { slots, attributes, props }) {
  return autobindMethods(
    runPlugins(
      defineProperties(
        isObject(component2) ? Object.create(component2) : component2,
        {
          mount(element, state = {}, parentScope) {
            defineProperty(element, IS_PURE_SYMBOL, false);
            this[PARENT_KEY_SYMBOL] = parentScope;
            this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(
              element,
              attributes
            ).mount(parentScope);
            defineProperty(
              this,
              PROPS_KEY,
              Object.freeze({
                ...computeInitialProps(element, props),
                ...evaluateAttributeExpressions(
                  this[ATTRIBUTES_KEY_SYMBOL].expressions
                )
              })
            );
            this[STATE_KEY] = computeComponentState(this[STATE_KEY], state);
            this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone();
            bindDOMNodeToComponentInstance(element, this);
            component2.name && addCssHook(element, component2.name);
            defineProperty(this, ROOT_KEY, element);
            defineProperty(this, SLOTS_KEY, slots);
            this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);
            this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);
            this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);
            return this;
          },
          update(state = {}, parentScope) {
            if (parentScope) {
              this[PARENT_KEY_SYMBOL] = parentScope;
              this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);
            }
            const computedAttributeNames = getRootComputedAttributeNames(
              this[TEMPLATE_KEY_SYMBOL]
            );
            const staticRootAttributes = Array.from(
              this[ROOT_KEY].attributes
            ).filter(({ name }) => !computedAttributeNames.includes(name));
            const domNodeAttributes = DOMattributesToObject({
              attributes: staticRootAttributes
            });
            const { [IS_DIRECTIVE]: _, ...newProps } = {
              ...domNodeAttributes,
              ...evaluateAttributeExpressions(
                this[ATTRIBUTES_KEY_SYMBOL].expressions
              )
            };
            if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false)
              return;
            defineProperty(
              this,
              PROPS_KEY,
              Object.freeze({
                // only root components will merge their initial props with the new ones
                // children components will just get them overridden see also https://github.com/riot/riot/issues/2978
                ...parentScope ? pick(this[PROPS_KEY], computedAttributeNames) : this[PROPS_KEY],
                ...newProps
              })
            );
            this[STATE_KEY] = computeComponentState(this[STATE_KEY], state);
            this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]);
            if (!this[IS_COMPONENT_UPDATING]) {
              this[IS_COMPONENT_UPDATING] = true;
              this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);
            }
            this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);
            this[IS_COMPONENT_UPDATING] = false;
            return this;
          },
          unmount(preserveRoot) {
            this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);
            this[ATTRIBUTES_KEY_SYMBOL].unmount();
            this[TEMPLATE_KEY_SYMBOL].unmount(
              this,
              this[PARENT_KEY_SYMBOL],
              preserveRoot === null ? null : !preserveRoot
            );
            this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);
            return this;
          }
        }
      )
    ),
    Object.keys(component2).filter((prop) => isFunction(component2[prop]))
  );
}

// node_modules/riot/esm/core/instantiate-component.js
function instantiateComponent({ css, template, componentAPI, name }) {
  if (css && name) cssManager.add(name, css);
  return curry(manageComponentLifecycle)(
    defineProperties(
      // set the component defaults without overriding the original component API
      defineDefaults(componentAPI, {
        ...COMPONENT_LIFECYCLE_METHODS,
        [PROPS_KEY]: {},
        [STATE_KEY]: {}
      }),
      {
        // defined during the component creation
        [SLOTS_KEY]: null,
        [ROOT_KEY]: null,
        // these properties should not be overriden
        ...COMPONENT_DOM_SELECTORS,
        name,
        css,
        template
      }
    )
  );
}

// node_modules/riot/esm/core/create-component-from-wrapper.js
function createChildrenComponentsObject(components = {}) {
  return Object.entries(callOrAssign(components)).reduce(
    (acc, [key, value]) => {
      acc[camelToDashCase(key)] = createComponentFromWrapper(value);
      return acc;
    },
    {}
  );
}
var createChildComponentGetter = (componentWrapper) => {
  const childrenComponents = createChildrenComponentsObject(
    componentWrapper.exports ? componentWrapper.exports.components : {}
  );
  return (name) => {
    if (name === componentWrapper.name)
      return memoizedCreateComponentFromWrapper(componentWrapper);
    return childrenComponents[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name);
  };
};
var memoizedCreateComponentFromWrapper = memoize(createComponentFromWrapper);
function createComponentFromWrapper(componentWrapper) {
  const { css, template, exports, name } = componentWrapper;
  const templateFn = template ? componentTemplateFactory(
    template,
    componentWrapper,
    createChildComponentGetter(componentWrapper)
  ) : MOCKED_TEMPLATE_INTERFACE;
  return ({ slots, attributes, props }) => {
    if (exports && exports[IS_PURE_SYMBOL])
      return createPureComponent(exports, {
        slots,
        attributes,
        props,
        css,
        template
      });
    const componentAPI = callOrAssign(exports) || {};
    const component2 = instantiateComponent({
      css,
      template: templateFn,
      componentAPI,
      name
    })({ slots, attributes, props });
    return {
      mount(element, parentScope, state) {
        return component2.mount(element, state, parentScope);
      },
      update(parentScope, state) {
        return component2.update(state, parentScope);
      },
      unmount(preserveRoot) {
        return component2.unmount(preserveRoot);
      }
    };
  };
}

// node_modules/riot/esm/api/register.js
function register(name, { css, template, exports }) {
  if (COMPONENTS_IMPLEMENTATION_MAP.has(name))
    panic(`The component "${name}" was already registered`);
  COMPONENTS_IMPLEMENTATION_MAP.set(
    name,
    createComponentFromWrapper({ name, css, template, exports })
  );
  return COMPONENTS_IMPLEMENTATION_MAP;
}

// node_modules/riot/esm/api/unregister.js
function unregister(name) {
  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name))
    panic(`The component "${name}" was never registered`);
  COMPONENTS_IMPLEMENTATION_MAP.delete(name);
  cssManager.remove(name);
  return COMPONENTS_IMPLEMENTATION_MAP;
}

// node_modules/riot/esm/core/mount-component.js
function mountComponent(element, initialProps, componentName, slots) {
  const name = componentName || getName(element);
  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name))
    panic(`The component named "${name}" was never registered`);
  const component2 = COMPONENTS_IMPLEMENTATION_MAP.get(name)({
    props: initialProps,
    slots
  });
  return component2.mount(element);
}

// node_modules/riot/esm/api/mount.js
function mount(selector, initialProps, name) {
  return $(selector).map(
    (element) => mountComponent(element, initialProps, name)
  );
}

// node_modules/riot/esm/api/unmount.js
function unmount(selector, keepRootElement) {
  return $(selector).map((element) => {
    if (element[DOM_COMPONENT_INSTANCE_PROPERTY]) {
      element[DOM_COMPONENT_INSTANCE_PROPERTY].unmount(keepRootElement);
    }
    return element;
  });
}

// node_modules/riot/esm/api/install.js
function install(plugin) {
  if (!isFunction(plugin)) panic("Plugins must be of type function");
  if (PLUGINS_SET.has(plugin)) panic("This plugin was already installed");
  PLUGINS_SET.add(plugin);
  return PLUGINS_SET;
}

// node_modules/riot/esm/api/uninstall.js
function uninstall(plugin) {
  if (!PLUGINS_SET.has(plugin)) panic("This plugin was never installed");
  PLUGINS_SET.delete(plugin);
  return PLUGINS_SET;
}

// node_modules/riot/esm/dependencies/cumpa/index.js
function compose(...fns) {
  return fns.reduce((f, g) => (...args) => f(g(...args)));
}

// node_modules/riot/esm/api/component.js
function component(implementation) {
  return (el, props, { slots, attributes, parentScope } = {}) => compose(
    (c) => c.mount(el, parentScope),
    (c) => c({ props, slots, attributes }),
    createComponentFromWrapper
  )(implementation);
}

// node_modules/riot/esm/api/pure.js
function pure(func) {
  if (!isFunction(func))
    panic('riot.pure accepts only arguments of type "function"');
  func[IS_PURE_SYMBOL] = true;
  return func;
}

// node_modules/riot/esm/api/with-types.js
var withTypes = (component2) => component2;

// node_modules/riot/esm/api/version.js
var version = "v9.1.8";

// node_modules/riot/esm/api/__.js
var __ = {
  cssManager,
  DOMBindings: {
    template: create,
    createBinding: create$1,
    createExpression: create$4,
    bindingTypes,
    expressionTypes
  },
  globals: {
    PROPS_KEY,
    STATE_KEY,
    IS_COMPONENT_UPDATING,
    ATTRIBUTES_KEY_SYMBOL,
    COMPONENTS_IMPLEMENTATION_MAP,
    PLUGINS_SET,
    DOM_COMPONENT_INSTANCE_PROPERTY,
    PARENT_KEY_SYMBOL
  }
};
export {
  __,
  component,
  install,
  mount,
  pure,
  register,
  uninstall,
  unmount,
  unregister,
  version,
  withTypes
};
/*! Bundled license information:

riot/esm/dependencies/@riotjs/util/constants.js:
  (* Riot WIP, @license MIT *)

riot/esm/dependencies/@riotjs/util/expression-types.js:
  (* Riot WIP, @license MIT *)

riot/esm/dependencies/@riotjs/util/strings.js:
  (* Riot WIP, @license MIT *)

riot/esm/dependencies/@riotjs/util/misc.js:
  (* Riot WIP, @license MIT *)

riot/esm/dependencies/@riotjs/util/checks.js:
  (* Riot WIP, @license MIT *)

riot/esm/dependencies/@riotjs/util/functions.js:
  (* Riot WIP, @license MIT *)

riot/esm/dependencies/@riotjs/util/dom.js:
  (* Riot WIP, @license MIT *)

riot/esm/core/mocked-template-interface.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/dependencies/@riotjs/util/binding-types.js:
  (* Riot WIP, @license MIT *)

riot/esm/dependencies/@riotjs/util/objects.js:
  (* Riot WIP, @license MIT *)

riot/esm/dependencies/@riotjs/dom-bindings/dist/dom-bindings.js:
  (* Riot WIP, @license MIT *)

riot/esm/core/component-template-factory.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/core/pure-component-api.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/core/bind-dom-node-to-component-instance.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/core/create-core-api-methods.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/core/create-pure-component.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/dependencies/bianco.dom-to-array/index.next.js:
  (* Riot WIP, @license MIT *)

riot/esm/dependencies/bianco.query/index.next.js:
  (* Riot WIP, @license MIT *)

riot/esm/core/component-dom-selectors.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/core/component-lifecycle-methods.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/dependencies/bianco.attr/index.next.js:
  (* Riot WIP, @license MIT *)

riot/esm/core/css-manager.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/dependencies/curri/index.js:
  (* Riot WIP, @license MIT *)

riot/esm/utils/dom.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/core/add-css-hook.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/core/compute-component-state.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/core/compute-initial-props.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/core/create-attribute-bindings.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/core/run-plugins.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/utils/get-root-computed-attribute-names.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/core/manage-component-lifecycle.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/core/instantiate-component.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/core/create-component-from-wrapper.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/api/register.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/api/unregister.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/core/mount-component.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/api/mount.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/api/unmount.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/api/install.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/api/uninstall.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/dependencies/cumpa/index.js:
  (* Riot WIP, @license MIT *)

riot/esm/api/component.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/api/pure.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/api/with-types.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/api/version.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/api/__.js:
  (* Riot v9.1.8, @license MIT *)

riot/esm/riot.js:
  (* Riot v9.1.8, @license MIT *)
*/
//# sourceMappingURL=riot.js.map
