/* Riot Compiler, @license MIT */
import riotParser, { constants, nodeTypes } from '@riotjs/parser';
import { types as types$1, parse, print } from 'recast';
import compose from 'cumpa';
import { isNil, isNode, isObject } from '@riotjs/util/checks';
import { hasValueAttribute } from 'dom-nodes';
import { parse as parse$1 } from 'recast/parsers/typescript.js';
import { composeSourceMaps } from 'recast/lib/util.js';
import { SourceMapGenerator } from 'source-map';
import { panic } from '@riotjs/util/misc';
import cssEscape from 'cssesc';
import curry from 'curri';

const TAG_LOGIC_PROPERTY = 'exports';
const TAG_CSS_PROPERTY = 'css';
const TAG_TEMPLATE_PROPERTY = 'template';
const TAG_NAME_PROPERTY = 'name';
const RIOT_MODULE_ID = 'riot';
const RIOT_INTERFACE_WRAPPER_NAME = 'RiotComponentWrapper';
const RIOT_TAG_INTERFACE_NAME = 'RiotComponent';

const BINDING_TYPES = 'bindingTypes';
const EACH_BINDING_TYPE = 'EACH';
const IF_BINDING_TYPE = 'IF';
const TAG_BINDING_TYPE = 'TAG';
const SLOT_BINDING_TYPE = 'SLOT';

const EXPRESSION_TYPES = 'expressionTypes';
const ATTRIBUTE_EXPRESSION_TYPE = 'ATTRIBUTE';
const VALUE_EXPRESSION_TYPE = 'VALUE';
const TEXT_EXPRESSION_TYPE = 'TEXT';
const EVENT_EXPRESSION_TYPE = 'EVENT';

const TEMPLATE_FN = 'template';
const SCOPE = '_scope';
const GET_COMPONENT_FN = 'getComponent';

// keys needed to create the DOM bindings
const BINDING_SELECTOR_KEY = 'selector';
const BINDING_GET_COMPONENT_KEY = 'getComponent';
const BINDING_TEMPLATE_KEY = 'template';
const BINDING_TYPE_KEY = 'type';
const BINDING_REDUNDANT_ATTRIBUTE_KEY = 'redundantAttribute';
const BINDING_CONDITION_KEY = 'condition';
const BINDING_ITEM_NAME_KEY = 'itemName';
const BINDING_GET_KEY_KEY = 'getKey';
const BINDING_INDEX_NAME_KEY = 'indexName';
const BINDING_EVALUATE_KEY = 'evaluate';
const BINDING_NAME_KEY = 'name';
const BINDING_SLOTS_KEY = 'slots';
const BINDING_EXPRESSIONS_KEY = 'expressions';
const BINDING_IS_BOOLEAN_ATTRIBUTE = 'isBoolean';
const BINDING_CHILD_NODE_INDEX_KEY = 'childNodeIndex';
// slots keys
const BINDING_BINDINGS_KEY = 'bindings';
const BINDING_ID_KEY = 'id';
const BINDING_HTML_KEY = 'html';
const BINDING_ATTRIBUTES_KEY = 'attributes';

// DOM directives
const IF_DIRECTIVE = 'if';
const EACH_DIRECTIVE = 'each';
const KEY_ATTRIBUTE = 'key';
const SLOT_ATTRIBUTE = 'slot';
const NAME_ATTRIBUTE = 'name';
const IS_DIRECTIVE = 'is';

// Misc
const DEFAULT_SLOT_NAME = 'default';
const TEXT_NODE_EXPRESSION_PLACEHOLDER = ' ';
const BINDING_SELECTOR_PREFIX = 'expr';
const SLOT_TAG_NODE_NAME = 'slot';
const PROGRESS_TAG_NODE_NAME = 'progress';
const TEMPLATE_TAG_NODE_NAME = 'template';

// Riot Parser constants
constants.IS_RAW;
const IS_VOID_NODE = constants.IS_VOID;
const IS_CUSTOM_NODE = constants.IS_CUSTOM;
const IS_BOOLEAN_ATTRIBUTE = constants.IS_BOOLEAN;
const IS_SPREAD_ATTRIBUTE = constants.IS_SPREAD;

const types = types$1;
const builders = types$1.builders;
const namedTypes = types$1.namedTypes;

var builtin = {
	AggregateError: false,
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	BigInt: false,
	BigInt64Array: false,
	BigUint64Array: false,
	"Boolean": false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	FinalizationRegistry: false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	globalThis: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"Intl": false,
	"isFinite": false,
	"isNaN": false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	"WeakMap": false,
	WeakRef: false,
	"WeakSet": false
};
var es5 = {
	"Array": false,
	"Boolean": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Function": false,
	"Infinity": false,
	"isFinite": false,
	"isNaN": false,
	"JSON": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"RangeError": false,
	"ReferenceError": false,
	"RegExp": false,
	"String": false,
	"SyntaxError": false,
	"TypeError": false,
	"undefined": false,
	"unescape": false,
	"URIError": false
};
var es2015 = {
	"Array": false,
	"ArrayBuffer": false,
	"Boolean": false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"Intl": false,
	"isFinite": false,
	"isNaN": false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	"WeakMap": false,
	"WeakSet": false
};
var es2017 = {
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	"Boolean": false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"Intl": false,
	"isFinite": false,
	"isNaN": false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	"WeakMap": false,
	"WeakSet": false
};
var es2020 = {
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	BigInt: false,
	BigInt64Array: false,
	BigUint64Array: false,
	"Boolean": false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	globalThis: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"Intl": false,
	"isFinite": false,
	"isNaN": false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	"WeakMap": false,
	"WeakSet": false
};
var es2021 = {
	AggregateError: false,
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	BigInt: false,
	BigInt64Array: false,
	BigUint64Array: false,
	"Boolean": false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	FinalizationRegistry: false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	globalThis: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"Intl": false,
	"isFinite": false,
	"isNaN": false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	"WeakMap": false,
	WeakRef: false,
	"WeakSet": false
};
var browser = {
	AbortController: false,
	AbortSignal: false,
	AbsoluteOrientationSensor: false,
	AbstractRange: false,
	Accelerometer: false,
	addEventListener: false,
	alert: false,
	AnalyserNode: false,
	Animation: false,
	AnimationEffect: false,
	AnimationEvent: false,
	AnimationPlaybackEvent: false,
	AnimationTimeline: false,
	atob: false,
	Attr: false,
	Audio: false,
	AudioBuffer: false,
	AudioBufferSourceNode: false,
	AudioContext: false,
	AudioData: false,
	AudioDecoder: false,
	AudioDestinationNode: false,
	AudioEncoder: false,
	AudioListener: false,
	AudioNode: false,
	AudioParam: false,
	AudioParamMap: false,
	AudioProcessingEvent: false,
	AudioScheduledSourceNode: false,
	AudioSinkInfo: false,
	AudioWorklet: false,
	AudioWorkletNode: false,
	AuthenticatorAssertionResponse: false,
	AuthenticatorAttestationResponse: false,
	AuthenticatorResponse: false,
	BackgroundFetchManager: false,
	BackgroundFetchRecord: false,
	BackgroundFetchRegistration: false,
	BarProp: false,
	BaseAudioContext: false,
	BatteryManager: false,
	BeforeUnloadEvent: false,
	BiquadFilterNode: false,
	Blob: false,
	BlobEvent: false,
	Bluetooth: false,
	BluetoothCharacteristicProperties: false,
	BluetoothDevice: false,
	BluetoothRemoteGATTCharacteristic: false,
	BluetoothRemoteGATTDescriptor: false,
	BluetoothRemoteGATTServer: false,
	BluetoothRemoteGATTService: false,
	BluetoothUUID: false,
	blur: false,
	BroadcastChannel: false,
	BrowserCaptureMediaStreamTrack: false,
	btoa: false,
	ByteLengthQueuingStrategy: false,
	Cache: false,
	caches: false,
	CacheStorage: false,
	cancelAnimationFrame: false,
	cancelIdleCallback: false,
	CanvasCaptureMediaStream: false,
	CanvasCaptureMediaStreamTrack: false,
	CanvasGradient: false,
	CanvasPattern: false,
	CanvasRenderingContext2D: false,
	CaptureController: false,
	CaretPosition: false,
	CDATASection: false,
	ChannelMergerNode: false,
	ChannelSplitterNode: false,
	CharacterBoundsUpdateEvent: false,
	CharacterData: false,
	clearInterval: false,
	clearTimeout: false,
	clientInformation: false,
	Clipboard: false,
	ClipboardEvent: false,
	ClipboardItem: false,
	close: false,
	closed: false,
	CloseEvent: false,
	Comment: false,
	CompositionEvent: false,
	CompressionStream: false,
	confirm: false,
	console: false,
	ConstantSourceNode: false,
	ContentVisibilityAutoStateChangeEvent: false,
	ConvolverNode: false,
	CookieChangeEvent: false,
	cookieStore: false,
	CookieStore: false,
	CookieStoreManager: false,
	CountQueuingStrategy: false,
	createImageBitmap: false,
	Credential: false,
	credentialless: false,
	CredentialsContainer: false,
	CropTarget: false,
	crossOriginIsolated: false,
	crypto: false,
	Crypto: false,
	CryptoKey: false,
	CSS: false,
	CSSAnimation: false,
	CSSConditionRule: false,
	CSSContainerRule: false,
	CSSCounterStyleRule: false,
	CSSFontFaceRule: false,
	CSSFontFeatureValuesRule: false,
	CSSFontPaletteValuesRule: false,
	CSSGroupingRule: false,
	CSSImageValue: false,
	CSSImportRule: false,
	CSSKeyframeRule: false,
	CSSKeyframesRule: false,
	CSSKeywordValue: false,
	CSSLayerBlockRule: false,
	CSSLayerStatementRule: false,
	CSSMathClamp: false,
	CSSMathInvert: false,
	CSSMathMax: false,
	CSSMathMin: false,
	CSSMathNegate: false,
	CSSMathProduct: false,
	CSSMathSum: false,
	CSSMathValue: false,
	CSSMatrixComponent: false,
	CSSMediaRule: false,
	CSSNamespaceRule: false,
	CSSNumericArray: false,
	CSSNumericValue: false,
	CSSPageRule: false,
	CSSPerspective: false,
	CSSPositionValue: false,
	CSSPropertyRule: false,
	CSSRotate: false,
	CSSRule: false,
	CSSRuleList: false,
	CSSScale: false,
	CSSScopeRule: false,
	CSSSkew: false,
	CSSSkewX: false,
	CSSSkewY: false,
	CSSStartingStyleRule: false,
	CSSStyleDeclaration: false,
	CSSStyleRule: false,
	CSSStyleSheet: false,
	CSSStyleValue: false,
	CSSSupportsRule: false,
	CSSTransformComponent: false,
	CSSTransformValue: false,
	CSSTransition: false,
	CSSTranslate: false,
	CSSUnitValue: false,
	CSSUnparsedValue: false,
	CSSVariableReferenceValue: false,
	CustomElementRegistry: false,
	customElements: false,
	CustomEvent: false,
	CustomStateSet: false,
	DataTransfer: false,
	DataTransferItem: false,
	DataTransferItemList: false,
	DecompressionStream: false,
	DelayNode: false,
	DelegatedInkTrailPresenter: false,
	DeviceMotionEvent: false,
	DeviceMotionEventAcceleration: false,
	DeviceMotionEventRotationRate: false,
	DeviceOrientationEvent: false,
	devicePixelRatio: false,
	dispatchEvent: false,
	document: false,
	Document: false,
	DocumentFragment: false,
	documentPictureInPicture: false,
	DocumentPictureInPicture: false,
	DocumentPictureInPictureEvent: false,
	DocumentTimeline: false,
	DocumentType: false,
	DOMError: false,
	DOMException: false,
	DOMImplementation: false,
	DOMMatrix: false,
	DOMMatrixReadOnly: false,
	DOMParser: false,
	DOMPoint: false,
	DOMPointReadOnly: false,
	DOMQuad: false,
	DOMRect: false,
	DOMRectList: false,
	DOMRectReadOnly: false,
	DOMStringList: false,
	DOMStringMap: false,
	DOMTokenList: false,
	DragEvent: false,
	DynamicsCompressorNode: false,
	EditContext: false,
	Element: false,
	ElementInternals: false,
	EncodedAudioChunk: false,
	EncodedVideoChunk: false,
	ErrorEvent: false,
	event: false,
	Event: false,
	EventCounts: false,
	EventSource: false,
	EventTarget: false,
	external: false,
	External: false,
	EyeDropper: false,
	FeaturePolicy: false,
	FederatedCredential: false,
	fetch: false,
	File: false,
	FileList: false,
	FileReader: false,
	FileSystem: false,
	FileSystemDirectoryEntry: false,
	FileSystemDirectoryHandle: false,
	FileSystemDirectoryReader: false,
	FileSystemEntry: false,
	FileSystemFileEntry: false,
	FileSystemFileHandle: false,
	FileSystemHandle: false,
	FileSystemWritableFileStream: false,
	find: false,
	focus: false,
	FocusEvent: false,
	FontData: false,
	FontFace: false,
	FontFaceSet: false,
	FontFaceSetLoadEvent: false,
	FormData: false,
	FormDataEvent: false,
	FragmentDirective: false,
	frameElement: false,
	frames: false,
	GainNode: false,
	Gamepad: false,
	GamepadAxisMoveEvent: false,
	GamepadButton: false,
	GamepadButtonEvent: false,
	GamepadEvent: false,
	GamepadHapticActuator: false,
	GamepadPose: false,
	Geolocation: false,
	GeolocationCoordinates: false,
	GeolocationPosition: false,
	GeolocationPositionError: false,
	getComputedStyle: false,
	getScreenDetails: false,
	getSelection: false,
	GPU: false,
	GPUAdapter: false,
	GPUAdapterInfo: false,
	GPUBindGroup: false,
	GPUBindGroupLayout: false,
	GPUBuffer: false,
	GPUBufferUsage: false,
	GPUCanvasContext: false,
	GPUColorWrite: false,
	GPUCommandBuffer: false,
	GPUCommandEncoder: false,
	GPUCompilationInfo: false,
	GPUCompilationMessage: false,
	GPUComputePassEncoder: false,
	GPUComputePipeline: false,
	GPUDevice: false,
	GPUDeviceLostInfo: false,
	GPUError: false,
	GPUExternalTexture: false,
	GPUInternalError: false,
	GPUMapMode: false,
	GPUOutOfMemoryError: false,
	GPUPipelineError: false,
	GPUPipelineLayout: false,
	GPUQuerySet: false,
	GPUQueue: false,
	GPURenderBundle: false,
	GPURenderBundleEncoder: false,
	GPURenderPassEncoder: false,
	GPURenderPipeline: false,
	GPUSampler: false,
	GPUShaderModule: false,
	GPUShaderStage: false,
	GPUSupportedFeatures: false,
	GPUSupportedLimits: false,
	GPUTexture: false,
	GPUTextureUsage: false,
	GPUTextureView: false,
	GPUUncapturedErrorEvent: false,
	GPUValidationError: false,
	GravitySensor: false,
	Gyroscope: false,
	HashChangeEvent: false,
	Headers: false,
	HID: false,
	HIDConnectionEvent: false,
	HIDDevice: false,
	HIDInputReportEvent: false,
	Highlight: false,
	HighlightRegistry: false,
	history: false,
	History: false,
	HTMLAllCollection: false,
	HTMLAnchorElement: false,
	HTMLAreaElement: false,
	HTMLAudioElement: false,
	HTMLBaseElement: false,
	HTMLBodyElement: false,
	HTMLBRElement: false,
	HTMLButtonElement: false,
	HTMLCanvasElement: false,
	HTMLCollection: false,
	HTMLDataElement: false,
	HTMLDataListElement: false,
	HTMLDetailsElement: false,
	HTMLDialogElement: false,
	HTMLDirectoryElement: false,
	HTMLDivElement: false,
	HTMLDListElement: false,
	HTMLDocument: false,
	HTMLElement: false,
	HTMLEmbedElement: false,
	HTMLFieldSetElement: false,
	HTMLFontElement: false,
	HTMLFormControlsCollection: false,
	HTMLFormElement: false,
	HTMLFrameElement: false,
	HTMLFrameSetElement: false,
	HTMLHeadElement: false,
	HTMLHeadingElement: false,
	HTMLHRElement: false,
	HTMLHtmlElement: false,
	HTMLIFrameElement: false,
	HTMLImageElement: false,
	HTMLInputElement: false,
	HTMLLabelElement: false,
	HTMLLegendElement: false,
	HTMLLIElement: false,
	HTMLLinkElement: false,
	HTMLMapElement: false,
	HTMLMarqueeElement: false,
	HTMLMediaElement: false,
	HTMLMenuElement: false,
	HTMLMetaElement: false,
	HTMLMeterElement: false,
	HTMLModElement: false,
	HTMLObjectElement: false,
	HTMLOListElement: false,
	HTMLOptGroupElement: false,
	HTMLOptionElement: false,
	HTMLOptionsCollection: false,
	HTMLOutputElement: false,
	HTMLParagraphElement: false,
	HTMLParamElement: false,
	HTMLPictureElement: false,
	HTMLPreElement: false,
	HTMLProgressElement: false,
	HTMLQuoteElement: false,
	HTMLScriptElement: false,
	HTMLSelectElement: false,
	HTMLSlotElement: false,
	HTMLSourceElement: false,
	HTMLSpanElement: false,
	HTMLStyleElement: false,
	HTMLTableCaptionElement: false,
	HTMLTableCellElement: false,
	HTMLTableColElement: false,
	HTMLTableElement: false,
	HTMLTableRowElement: false,
	HTMLTableSectionElement: false,
	HTMLTemplateElement: false,
	HTMLTextAreaElement: false,
	HTMLTimeElement: false,
	HTMLTitleElement: false,
	HTMLTrackElement: false,
	HTMLUListElement: false,
	HTMLUnknownElement: false,
	HTMLVideoElement: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	IdentityCredential: false,
	IdentityCredentialError: false,
	IdentityProvider: false,
	IdleDeadline: false,
	IdleDetector: false,
	IIRFilterNode: false,
	Image: false,
	ImageBitmap: false,
	ImageBitmapRenderingContext: false,
	ImageCapture: false,
	ImageData: false,
	ImageDecoder: false,
	ImageTrack: false,
	ImageTrackList: false,
	indexedDB: false,
	Ink: false,
	innerHeight: false,
	innerWidth: false,
	InputDeviceCapabilities: false,
	InputDeviceInfo: false,
	InputEvent: false,
	IntersectionObserver: false,
	IntersectionObserverEntry: false,
	isSecureContext: false,
	Iterator: false,
	Keyboard: false,
	KeyboardEvent: false,
	KeyboardLayoutMap: false,
	KeyframeEffect: false,
	LargestContentfulPaint: false,
	LaunchParams: false,
	launchQueue: false,
	LaunchQueue: false,
	LayoutShift: false,
	LayoutShiftAttribution: false,
	length: false,
	LinearAccelerationSensor: false,
	localStorage: false,
	location: true,
	Location: false,
	locationbar: false,
	Lock: false,
	LockManager: false,
	matchMedia: false,
	MathMLElement: false,
	MediaCapabilities: false,
	MediaCapabilitiesInfo: false,
	MediaDeviceInfo: false,
	MediaDevices: false,
	MediaElementAudioSourceNode: false,
	MediaEncryptedEvent: false,
	MediaError: false,
	MediaKeyError: false,
	MediaKeyMessageEvent: false,
	MediaKeys: false,
	MediaKeySession: false,
	MediaKeyStatusMap: false,
	MediaKeySystemAccess: false,
	MediaList: false,
	MediaMetadata: false,
	MediaQueryList: false,
	MediaQueryListEvent: false,
	MediaRecorder: false,
	MediaRecorderErrorEvent: false,
	MediaSession: false,
	MediaSource: false,
	MediaSourceHandle: false,
	MediaStream: false,
	MediaStreamAudioDestinationNode: false,
	MediaStreamAudioSourceNode: false,
	MediaStreamEvent: false,
	MediaStreamTrack: false,
	MediaStreamTrackAudioSourceNode: false,
	MediaStreamTrackEvent: false,
	MediaStreamTrackGenerator: false,
	MediaStreamTrackProcessor: false,
	MediaStreamTrackVideoStats: false,
	menubar: false,
	MessageChannel: false,
	MessageEvent: false,
	MessagePort: false,
	MIDIAccess: false,
	MIDIConnectionEvent: false,
	MIDIInput: false,
	MIDIInputMap: false,
	MIDIMessageEvent: false,
	MIDIOutput: false,
	MIDIOutputMap: false,
	MIDIPort: false,
	MimeType: false,
	MimeTypeArray: false,
	MouseEvent: false,
	moveBy: false,
	moveTo: false,
	MutationEvent: false,
	MutationObserver: false,
	MutationRecord: false,
	name: false,
	NamedNodeMap: false,
	NavigateEvent: false,
	navigation: false,
	Navigation: false,
	NavigationActivation: false,
	NavigationCurrentEntryChangeEvent: false,
	NavigationDestination: false,
	NavigationHistoryEntry: false,
	NavigationPreloadManager: false,
	NavigationTransition: false,
	navigator: false,
	Navigator: false,
	NavigatorLogin: false,
	NavigatorManagedData: false,
	NavigatorUAData: false,
	NetworkInformation: false,
	Node: false,
	NodeFilter: false,
	NodeIterator: false,
	NodeList: false,
	Notification: false,
	NotifyPaintEvent: false,
	OfflineAudioCompletionEvent: false,
	OfflineAudioContext: false,
	offscreenBuffering: false,
	OffscreenCanvas: false,
	OffscreenCanvasRenderingContext2D: false,
	onabort: true,
	onafterprint: true,
	onanimationcancel: true,
	onanimationend: true,
	onanimationiteration: true,
	onanimationstart: true,
	onappinstalled: true,
	onauxclick: true,
	onbeforeinput: true,
	onbeforeinstallprompt: true,
	onbeforematch: true,
	onbeforeprint: true,
	onbeforetoggle: true,
	onbeforeunload: true,
	onbeforexrselect: true,
	onblur: true,
	oncancel: true,
	oncanplay: true,
	oncanplaythrough: true,
	onchange: true,
	onclick: true,
	onclose: true,
	oncontentvisibilityautostatechange: true,
	oncontextlost: true,
	oncontextmenu: true,
	oncontextrestored: true,
	oncopy: true,
	oncuechange: true,
	oncut: true,
	ondblclick: true,
	ondevicemotion: true,
	ondeviceorientation: true,
	ondeviceorientationabsolute: true,
	ondrag: true,
	ondragend: true,
	ondragenter: true,
	ondragleave: true,
	ondragover: true,
	ondragstart: true,
	ondrop: true,
	ondurationchange: true,
	onemptied: true,
	onended: true,
	onerror: true,
	onfocus: true,
	onformdata: true,
	ongamepadconnected: true,
	ongamepaddisconnected: true,
	ongotpointercapture: true,
	onhashchange: true,
	oninput: true,
	oninvalid: true,
	onkeydown: true,
	onkeypress: true,
	onkeyup: true,
	onlanguagechange: true,
	onload: true,
	onloadeddata: true,
	onloadedmetadata: true,
	onloadstart: true,
	onlostpointercapture: true,
	onmessage: true,
	onmessageerror: true,
	onmousedown: true,
	onmouseenter: true,
	onmouseleave: true,
	onmousemove: true,
	onmouseout: true,
	onmouseover: true,
	onmouseup: true,
	onmousewheel: true,
	onoffline: true,
	ononline: true,
	onpagehide: true,
	onpagereveal: true,
	onpageshow: true,
	onpaste: true,
	onpause: true,
	onplay: true,
	onplaying: true,
	onpointercancel: true,
	onpointerdown: true,
	onpointerenter: true,
	onpointerleave: true,
	onpointermove: true,
	onpointerout: true,
	onpointerover: true,
	onpointerrawupdate: true,
	onpointerup: true,
	onpopstate: true,
	onprogress: true,
	onratechange: true,
	onrejectionhandled: true,
	onreset: true,
	onresize: true,
	onscroll: true,
	onscrollend: true,
	onsearch: true,
	onsecuritypolicyviolation: true,
	onseeked: true,
	onseeking: true,
	onselect: true,
	onselectionchange: true,
	onselectstart: true,
	onslotchange: true,
	onstalled: true,
	onstorage: true,
	onsubmit: true,
	onsuspend: true,
	ontimeupdate: true,
	ontoggle: true,
	ontransitioncancel: true,
	ontransitionend: true,
	ontransitionrun: true,
	ontransitionstart: true,
	onunhandledrejection: true,
	onunload: true,
	onvolumechange: true,
	onwaiting: true,
	onwheel: true,
	open: false,
	opener: false,
	Option: false,
	OrientationSensor: false,
	origin: false,
	originAgentCluster: false,
	OscillatorNode: false,
	OTPCredential: false,
	outerHeight: false,
	outerWidth: false,
	OverconstrainedError: false,
	PageRevealEvent: false,
	PageTransitionEvent: false,
	pageXOffset: false,
	pageYOffset: false,
	PannerNode: false,
	parent: false,
	PasswordCredential: false,
	Path2D: false,
	PaymentAddress: false,
	PaymentManager: false,
	PaymentMethodChangeEvent: false,
	PaymentRequest: false,
	PaymentRequestUpdateEvent: false,
	PaymentResponse: false,
	performance: false,
	Performance: false,
	PerformanceElementTiming: false,
	PerformanceEntry: false,
	PerformanceEventTiming: false,
	PerformanceLongAnimationFrameTiming: false,
	PerformanceLongTaskTiming: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceNavigationTiming: false,
	PerformanceObserver: false,
	PerformanceObserverEntryList: false,
	PerformancePaintTiming: false,
	PerformanceResourceTiming: false,
	PerformanceScriptTiming: false,
	PerformanceServerTiming: false,
	PerformanceTiming: false,
	PeriodicSyncManager: false,
	PeriodicWave: false,
	Permissions: false,
	PermissionStatus: false,
	PERSISTENT: false,
	personalbar: false,
	PictureInPictureEvent: false,
	PictureInPictureWindow: false,
	Plugin: false,
	PluginArray: false,
	PointerEvent: false,
	PopStateEvent: false,
	postMessage: false,
	Presentation: false,
	PresentationAvailability: false,
	PresentationConnection: false,
	PresentationConnectionAvailableEvent: false,
	PresentationConnectionCloseEvent: false,
	PresentationConnectionList: false,
	PresentationReceiver: false,
	PresentationRequest: false,
	print: false,
	ProcessingInstruction: false,
	Profiler: false,
	ProgressEvent: false,
	PromiseRejectionEvent: false,
	prompt: false,
	PublicKeyCredential: false,
	PushManager: false,
	PushSubscription: false,
	PushSubscriptionOptions: false,
	queryLocalFonts: false,
	queueMicrotask: false,
	RadioNodeList: false,
	Range: false,
	ReadableByteStreamController: false,
	ReadableStream: false,
	ReadableStreamBYOBReader: false,
	ReadableStreamBYOBRequest: false,
	ReadableStreamDefaultController: false,
	ReadableStreamDefaultReader: false,
	RelativeOrientationSensor: false,
	RemotePlayback: false,
	removeEventListener: false,
	reportError: false,
	ReportingObserver: false,
	Request: false,
	requestAnimationFrame: false,
	requestIdleCallback: false,
	resizeBy: false,
	ResizeObserver: false,
	ResizeObserverEntry: false,
	ResizeObserverSize: false,
	resizeTo: false,
	Response: false,
	RTCCertificate: false,
	RTCDataChannel: false,
	RTCDataChannelEvent: false,
	RTCDtlsTransport: false,
	RTCDTMFSender: false,
	RTCDTMFToneChangeEvent: false,
	RTCEncodedAudioFrame: false,
	RTCEncodedVideoFrame: false,
	RTCError: false,
	RTCErrorEvent: false,
	RTCIceCandidate: false,
	RTCIceTransport: false,
	RTCPeerConnection: false,
	RTCPeerConnectionIceErrorEvent: false,
	RTCPeerConnectionIceEvent: false,
	RTCRtpReceiver: false,
	RTCRtpScriptTransform: false,
	RTCRtpSender: false,
	RTCRtpTransceiver: false,
	RTCSctpTransport: false,
	RTCSessionDescription: false,
	RTCStatsReport: false,
	RTCTrackEvent: false,
	scheduler: false,
	Scheduler: false,
	Scheduling: false,
	screen: false,
	Screen: false,
	ScreenDetailed: false,
	ScreenDetails: false,
	screenLeft: false,
	ScreenOrientation: false,
	screenTop: false,
	screenX: false,
	screenY: false,
	ScriptProcessorNode: false,
	scroll: false,
	scrollbars: false,
	scrollBy: false,
	ScrollTimeline: false,
	scrollTo: false,
	scrollX: false,
	scrollY: false,
	SecurityPolicyViolationEvent: false,
	Selection: false,
	self: false,
	Sensor: false,
	SensorErrorEvent: false,
	Serial: false,
	SerialPort: false,
	ServiceWorker: false,
	ServiceWorkerContainer: false,
	ServiceWorkerRegistration: false,
	sessionStorage: false,
	setInterval: false,
	setTimeout: false,
	ShadowRoot: false,
	SharedWorker: false,
	showDirectoryPicker: false,
	showOpenFilePicker: false,
	showSaveFilePicker: false,
	SourceBuffer: false,
	SourceBufferList: false,
	speechSynthesis: false,
	SpeechSynthesis: false,
	SpeechSynthesisErrorEvent: false,
	SpeechSynthesisEvent: false,
	SpeechSynthesisUtterance: false,
	SpeechSynthesisVoice: false,
	StaticRange: false,
	status: false,
	statusbar: false,
	StereoPannerNode: false,
	stop: false,
	Storage: false,
	StorageBucket: false,
	StorageBucketManager: false,
	StorageEvent: false,
	StorageManager: false,
	structuredClone: false,
	styleMedia: false,
	StylePropertyMap: false,
	StylePropertyMapReadOnly: false,
	StyleSheet: false,
	StyleSheetList: false,
	SubmitEvent: false,
	SubtleCrypto: false,
	SVGAElement: false,
	SVGAngle: false,
	SVGAnimatedAngle: false,
	SVGAnimatedBoolean: false,
	SVGAnimatedEnumeration: false,
	SVGAnimatedInteger: false,
	SVGAnimatedLength: false,
	SVGAnimatedLengthList: false,
	SVGAnimatedNumber: false,
	SVGAnimatedNumberList: false,
	SVGAnimatedPreserveAspectRatio: false,
	SVGAnimatedRect: false,
	SVGAnimatedString: false,
	SVGAnimatedTransformList: false,
	SVGAnimateElement: false,
	SVGAnimateMotionElement: false,
	SVGAnimateTransformElement: false,
	SVGAnimationElement: false,
	SVGCircleElement: false,
	SVGClipPathElement: false,
	SVGComponentTransferFunctionElement: false,
	SVGDefsElement: false,
	SVGDescElement: false,
	SVGElement: false,
	SVGEllipseElement: false,
	SVGFEBlendElement: false,
	SVGFEColorMatrixElement: false,
	SVGFEComponentTransferElement: false,
	SVGFECompositeElement: false,
	SVGFEConvolveMatrixElement: false,
	SVGFEDiffuseLightingElement: false,
	SVGFEDisplacementMapElement: false,
	SVGFEDistantLightElement: false,
	SVGFEDropShadowElement: false,
	SVGFEFloodElement: false,
	SVGFEFuncAElement: false,
	SVGFEFuncBElement: false,
	SVGFEFuncGElement: false,
	SVGFEFuncRElement: false,
	SVGFEGaussianBlurElement: false,
	SVGFEImageElement: false,
	SVGFEMergeElement: false,
	SVGFEMergeNodeElement: false,
	SVGFEMorphologyElement: false,
	SVGFEOffsetElement: false,
	SVGFEPointLightElement: false,
	SVGFESpecularLightingElement: false,
	SVGFESpotLightElement: false,
	SVGFETileElement: false,
	SVGFETurbulenceElement: false,
	SVGFilterElement: false,
	SVGForeignObjectElement: false,
	SVGGElement: false,
	SVGGeometryElement: false,
	SVGGradientElement: false,
	SVGGraphicsElement: false,
	SVGImageElement: false,
	SVGLength: false,
	SVGLengthList: false,
	SVGLinearGradientElement: false,
	SVGLineElement: false,
	SVGMarkerElement: false,
	SVGMaskElement: false,
	SVGMatrix: false,
	SVGMetadataElement: false,
	SVGMPathElement: false,
	SVGNumber: false,
	SVGNumberList: false,
	SVGPathElement: false,
	SVGPatternElement: false,
	SVGPoint: false,
	SVGPointList: false,
	SVGPolygonElement: false,
	SVGPolylineElement: false,
	SVGPreserveAspectRatio: false,
	SVGRadialGradientElement: false,
	SVGRect: false,
	SVGRectElement: false,
	SVGScriptElement: false,
	SVGSetElement: false,
	SVGStopElement: false,
	SVGStringList: false,
	SVGStyleElement: false,
	SVGSVGElement: false,
	SVGSwitchElement: false,
	SVGSymbolElement: false,
	SVGTextContentElement: false,
	SVGTextElement: false,
	SVGTextPathElement: false,
	SVGTextPositioningElement: false,
	SVGTitleElement: false,
	SVGTransform: false,
	SVGTransformList: false,
	SVGTSpanElement: false,
	SVGUnitTypes: false,
	SVGUseElement: false,
	SVGViewElement: false,
	SyncManager: false,
	TaskAttributionTiming: false,
	TaskController: false,
	TaskPriorityChangeEvent: false,
	TaskSignal: false,
	TEMPORARY: false,
	Text: false,
	TextDecoder: false,
	TextDecoderStream: false,
	TextEncoder: false,
	TextEncoderStream: false,
	TextEvent: false,
	TextFormat: false,
	TextFormatUpdateEvent: false,
	TextMetrics: false,
	TextTrack: false,
	TextTrackCue: false,
	TextTrackCueList: false,
	TextTrackList: false,
	TextUpdateEvent: false,
	TimeEvent: false,
	TimeRanges: false,
	ToggleEvent: false,
	toolbar: false,
	top: false,
	Touch: false,
	TouchEvent: false,
	TouchList: false,
	TrackEvent: false,
	TransformStream: false,
	TransformStreamDefaultController: false,
	TransitionEvent: false,
	TreeWalker: false,
	TrustedHTML: false,
	TrustedScript: false,
	TrustedScriptURL: false,
	TrustedTypePolicy: false,
	TrustedTypePolicyFactory: false,
	trustedTypes: false,
	UIEvent: false,
	URL: false,
	URLPattern: false,
	URLSearchParams: false,
	USB: false,
	USBAlternateInterface: false,
	USBConfiguration: false,
	USBConnectionEvent: false,
	USBDevice: false,
	USBEndpoint: false,
	USBInterface: false,
	USBInTransferResult: false,
	USBIsochronousInTransferPacket: false,
	USBIsochronousInTransferResult: false,
	USBIsochronousOutTransferPacket: false,
	USBIsochronousOutTransferResult: false,
	USBOutTransferResult: false,
	UserActivation: false,
	ValidityState: false,
	VideoColorSpace: false,
	VideoDecoder: false,
	VideoEncoder: false,
	VideoFrame: false,
	VideoPlaybackQuality: false,
	ViewTimeline: false,
	ViewTransition: false,
	VirtualKeyboard: false,
	VirtualKeyboardGeometryChangeEvent: false,
	VisibilityStateEntry: false,
	visualViewport: false,
	VisualViewport: false,
	VTTCue: false,
	VTTRegion: false,
	WakeLock: false,
	WakeLockSentinel: false,
	WaveShaperNode: false,
	WebAssembly: false,
	WebGL2RenderingContext: false,
	WebGLActiveInfo: false,
	WebGLBuffer: false,
	WebGLContextEvent: false,
	WebGLFramebuffer: false,
	WebGLProgram: false,
	WebGLQuery: false,
	WebGLRenderbuffer: false,
	WebGLRenderingContext: false,
	WebGLSampler: false,
	WebGLShader: false,
	WebGLShaderPrecisionFormat: false,
	WebGLSync: false,
	WebGLTexture: false,
	WebGLTransformFeedback: false,
	WebGLUniformLocation: false,
	WebGLVertexArrayObject: false,
	WebSocket: false,
	WebTransport: false,
	WebTransportBidirectionalStream: false,
	WebTransportDatagramDuplexStream: false,
	WebTransportError: false,
	WebTransportReceiveStream: false,
	WebTransportSendStream: false,
	WGSLLanguageFeatures: false,
	WheelEvent: false,
	window: false,
	Window: false,
	WindowControlsOverlay: false,
	WindowControlsOverlayGeometryChangeEvent: false,
	Worker: false,
	Worklet: false,
	WritableStream: false,
	WritableStreamDefaultController: false,
	WritableStreamDefaultWriter: false,
	XMLDocument: false,
	XMLHttpRequest: false,
	XMLHttpRequestEventTarget: false,
	XMLHttpRequestUpload: false,
	XMLSerializer: false,
	XPathEvaluator: false,
	XPathExpression: false,
	XPathResult: false,
	XRAnchor: false,
	XRAnchorSet: false,
	XRBoundedReferenceSpace: false,
	XRCamera: false,
	XRCPUDepthInformation: false,
	XRDepthInformation: false,
	XRDOMOverlayState: false,
	XRFrame: false,
	XRHitTestResult: false,
	XRHitTestSource: false,
	XRInputSource: false,
	XRInputSourceArray: false,
	XRInputSourceEvent: false,
	XRInputSourcesChangeEvent: false,
	XRLayer: false,
	XRLightEstimate: false,
	XRLightProbe: false,
	XRPose: false,
	XRRay: false,
	XRReferenceSpace: false,
	XRReferenceSpaceEvent: false,
	XRRenderState: false,
	XRRigidTransform: false,
	XRSession: false,
	XRSessionEvent: false,
	XRSpace: false,
	XRSystem: false,
	XRTransientInputHitTestResult: false,
	XRTransientInputHitTestSource: false,
	XRView: false,
	XRViewerPose: false,
	XRViewport: false,
	XRWebGLBinding: false,
	XRWebGLDepthInformation: false,
	XRWebGLLayer: false,
	XSLTProcessor: false
};
var worker = {
	AbortController: false,
	AbortSignal: false,
	addEventListener: false,
	atob: false,
	AudioData: false,
	AudioDecoder: false,
	AudioEncoder: false,
	BackgroundFetchManager: false,
	BackgroundFetchRecord: false,
	BackgroundFetchRegistration: false,
	Blob: false,
	BroadcastChannel: false,
	btoa: false,
	ByteLengthQueuingStrategy: false,
	Cache: false,
	caches: false,
	CacheStorage: false,
	cancelAnimationFrame: false,
	CanvasGradient: false,
	CanvasPattern: false,
	clearInterval: false,
	clearTimeout: false,
	close: false,
	CloseEvent: false,
	CompressionStream: false,
	console: false,
	CountQueuingStrategy: false,
	createImageBitmap: false,
	CropTarget: false,
	crossOriginIsolated: false,
	crypto: false,
	Crypto: false,
	CryptoKey: false,
	CSSSkewX: false,
	CSSSkewY: false,
	CustomEvent: false,
	DecompressionStream: false,
	DedicatedWorkerGlobalScope: false,
	dispatchEvent: false,
	DOMException: false,
	DOMMatrix: false,
	DOMMatrixReadOnly: false,
	DOMPoint: false,
	DOMPointReadOnly: false,
	DOMQuad: false,
	DOMRect: false,
	DOMRectReadOnly: false,
	DOMStringList: false,
	EncodedAudioChunk: false,
	EncodedVideoChunk: false,
	ErrorEvent: false,
	Event: false,
	EventSource: false,
	EventTarget: false,
	fetch: false,
	File: false,
	FileList: false,
	FileReader: false,
	FileReaderSync: false,
	FileSystemDirectoryHandle: false,
	FileSystemFileHandle: false,
	FileSystemHandle: false,
	FileSystemSyncAccessHandle: false,
	FileSystemWritableFileStream: false,
	FontFace: false,
	fonts: false,
	FormData: false,
	GPU: false,
	GPUAdapter: false,
	GPUAdapterInfo: false,
	GPUBindGroup: false,
	GPUBindGroupLayout: false,
	GPUBuffer: false,
	GPUBufferUsage: false,
	GPUCanvasContext: false,
	GPUColorWrite: false,
	GPUCommandBuffer: false,
	GPUCommandEncoder: false,
	GPUCompilationInfo: false,
	GPUCompilationMessage: false,
	GPUComputePassEncoder: false,
	GPUComputePipeline: false,
	GPUDevice: false,
	GPUDeviceLostInfo: false,
	GPUError: false,
	GPUExternalTexture: false,
	GPUInternalError: false,
	GPUMapMode: false,
	GPUOutOfMemoryError: false,
	GPUPipelineError: false,
	GPUPipelineLayout: false,
	GPUQuerySet: false,
	GPUQueue: false,
	GPURenderBundle: false,
	GPURenderBundleEncoder: false,
	GPURenderPassEncoder: false,
	GPURenderPipeline: false,
	GPUSampler: false,
	GPUShaderModule: false,
	GPUShaderStage: false,
	GPUSupportedFeatures: false,
	GPUSupportedLimits: false,
	GPUTexture: false,
	GPUTextureUsage: false,
	GPUTextureView: false,
	GPUUncapturedErrorEvent: false,
	GPUValidationError: false,
	Headers: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	IdleDetector: false,
	ImageBitmap: false,
	ImageBitmapRenderingContext: false,
	ImageData: false,
	ImageDecoder: false,
	ImageTrack: false,
	ImageTrackList: false,
	importScripts: false,
	indexedDB: false,
	isSecureContext: false,
	Iterator: false,
	location: false,
	Lock: false,
	LockManager: false,
	MediaCapabilities: false,
	MediaSource: false,
	MediaSourceHandle: false,
	MessageChannel: false,
	MessageEvent: false,
	MessagePort: false,
	name: false,
	NavigationPreloadManager: false,
	navigator: false,
	NavigatorUAData: false,
	NetworkInformation: false,
	Notification: false,
	OffscreenCanvas: false,
	OffscreenCanvasRenderingContext2D: false,
	onerror: true,
	onlanguagechange: true,
	onmessage: true,
	onmessageerror: true,
	onrejectionhandled: true,
	onunhandledrejection: true,
	origin: false,
	Path2D: false,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceObserver: false,
	PerformanceObserverEntryList: false,
	PerformanceResourceTiming: false,
	PerformanceServerTiming: false,
	PeriodicSyncManager: false,
	Permissions: false,
	PermissionStatus: false,
	PERSISTENT: false,
	postMessage: false,
	ProgressEvent: false,
	PromiseRejectionEvent: false,
	PushManager: false,
	PushSubscription: false,
	PushSubscriptionOptions: false,
	queueMicrotask: false,
	ReadableByteStreamController: false,
	ReadableStream: false,
	ReadableStreamBYOBReader: false,
	ReadableStreamBYOBRequest: false,
	ReadableStreamDefaultController: false,
	ReadableStreamDefaultReader: false,
	removeEventListener: false,
	reportError: false,
	ReportingObserver: false,
	Request: false,
	requestAnimationFrame: false,
	Response: false,
	RTCEncodedAudioFrame: false,
	RTCEncodedVideoFrame: false,
	scheduler: false,
	Scheduler: false,
	SecurityPolicyViolationEvent: false,
	self: false,
	Serial: false,
	SerialPort: false,
	ServiceWorkerRegistration: false,
	setInterval: false,
	setTimeout: false,
	SourceBuffer: false,
	SourceBufferList: false,
	StorageBucket: false,
	StorageBucketManager: false,
	StorageManager: false,
	structuredClone: false,
	SubtleCrypto: false,
	SyncManager: false,
	TaskController: false,
	TaskPriorityChangeEvent: false,
	TaskSignal: false,
	TEMPORARY: false,
	TextDecoder: false,
	TextDecoderStream: false,
	TextEncoder: false,
	TextEncoderStream: false,
	TextMetrics: false,
	TransformStream: false,
	TransformStreamDefaultController: false,
	TrustedHTML: false,
	TrustedScript: false,
	TrustedScriptURL: false,
	TrustedTypePolicy: false,
	TrustedTypePolicyFactory: false,
	trustedTypes: false,
	URL: false,
	URLPattern: false,
	URLSearchParams: false,
	USB: false,
	USBAlternateInterface: false,
	USBConfiguration: false,
	USBConnectionEvent: false,
	USBDevice: false,
	USBEndpoint: false,
	USBInterface: false,
	USBInTransferResult: false,
	USBIsochronousInTransferPacket: false,
	USBIsochronousInTransferResult: false,
	USBIsochronousOutTransferPacket: false,
	USBIsochronousOutTransferResult: false,
	USBOutTransferResult: false,
	UserActivation: false,
	VideoColorSpace: false,
	VideoDecoder: false,
	VideoEncoder: false,
	VideoFrame: false,
	WebAssembly: false,
	WebGL2RenderingContext: false,
	WebGLActiveInfo: false,
	WebGLBuffer: false,
	WebGLContextEvent: false,
	WebGLFramebuffer: false,
	WebGLProgram: false,
	WebGLQuery: false,
	WebGLRenderbuffer: false,
	WebGLRenderingContext: false,
	WebGLSampler: false,
	WebGLShader: false,
	WebGLShaderPrecisionFormat: false,
	WebGLSync: false,
	WebGLTexture: false,
	WebGLTransformFeedback: false,
	WebGLUniformLocation: false,
	WebGLVertexArrayObject: false,
	webkitRequestFileSystem: false,
	webkitRequestFileSystemSync: false,
	webkitResolveLocalFileSystemSyncURL: false,
	webkitResolveLocalFileSystemURL: false,
	WebSocket: false,
	WebTransport: false,
	WebTransportBidirectionalStream: false,
	WebTransportDatagramDuplexStream: false,
	WebTransportError: false,
	WGSLLanguageFeatures: false,
	Worker: false,
	WorkerGlobalScope: false,
	WorkerLocation: false,
	WorkerNavigator: false,
	WritableStream: false,
	WritableStreamDefaultController: false,
	WritableStreamDefaultWriter: false,
	XMLHttpRequest: false,
	XMLHttpRequestEventTarget: false,
	XMLHttpRequestUpload: false
};
var node = {
	__dirname: false,
	__filename: false,
	AbortController: false,
	AbortSignal: false,
	atob: false,
	Blob: false,
	BroadcastChannel: false,
	btoa: false,
	Buffer: false,
	ByteLengthQueuingStrategy: false,
	clearImmediate: false,
	clearInterval: false,
	clearTimeout: false,
	CompressionStream: false,
	console: false,
	CountQueuingStrategy: false,
	crypto: false,
	Crypto: false,
	CryptoKey: false,
	CustomEvent: false,
	DecompressionStream: false,
	DOMException: false,
	Event: false,
	EventTarget: false,
	exports: true,
	fetch: false,
	File: false,
	FormData: false,
	global: false,
	Headers: false,
	MessageChannel: false,
	MessageEvent: false,
	MessagePort: false,
	module: false,
	navigator: false,
	Navigator: false,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceObserver: false,
	PerformanceObserverEntryList: false,
	PerformanceResourceTiming: false,
	process: false,
	queueMicrotask: false,
	ReadableByteStreamController: false,
	ReadableStream: false,
	ReadableStreamBYOBReader: false,
	ReadableStreamBYOBRequest: false,
	ReadableStreamDefaultController: false,
	ReadableStreamDefaultReader: false,
	Request: false,
	require: false,
	Response: false,
	setImmediate: false,
	setInterval: false,
	setTimeout: false,
	structuredClone: false,
	SubtleCrypto: false,
	TextDecoder: false,
	TextDecoderStream: false,
	TextEncoder: false,
	TextEncoderStream: false,
	TransformStream: false,
	TransformStreamDefaultController: false,
	URL: false,
	URLSearchParams: false,
	WebAssembly: false,
	WritableStream: false,
	WritableStreamDefaultController: false,
	WritableStreamDefaultWriter: false
};
var nodeBuiltin = {
	AbortController: false,
	AbortSignal: false,
	atob: false,
	Blob: false,
	BroadcastChannel: false,
	btoa: false,
	Buffer: false,
	ByteLengthQueuingStrategy: false,
	clearImmediate: false,
	clearInterval: false,
	clearTimeout: false,
	CompressionStream: false,
	console: false,
	CountQueuingStrategy: false,
	crypto: false,
	Crypto: false,
	CryptoKey: false,
	CustomEvent: false,
	DecompressionStream: false,
	DOMException: false,
	Event: false,
	EventTarget: false,
	fetch: false,
	File: false,
	FormData: false,
	global: false,
	Headers: false,
	MessageChannel: false,
	MessageEvent: false,
	MessagePort: false,
	navigator: false,
	Navigator: false,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceObserver: false,
	PerformanceObserverEntryList: false,
	PerformanceResourceTiming: false,
	process: false,
	queueMicrotask: false,
	ReadableByteStreamController: false,
	ReadableStream: false,
	ReadableStreamBYOBReader: false,
	ReadableStreamBYOBRequest: false,
	ReadableStreamDefaultController: false,
	ReadableStreamDefaultReader: false,
	Request: false,
	Response: false,
	setImmediate: false,
	setInterval: false,
	setTimeout: false,
	structuredClone: false,
	SubtleCrypto: false,
	TextDecoder: false,
	TextDecoderStream: false,
	TextEncoder: false,
	TextEncoderStream: false,
	TransformStream: false,
	TransformStreamDefaultController: false,
	URL: false,
	URLSearchParams: false,
	WebAssembly: false,
	WritableStream: false,
	WritableStreamDefaultController: false,
	WritableStreamDefaultWriter: false
};
var commonjs = {
	exports: true,
	global: false,
	module: false,
	require: false
};
var amd = {
	define: false,
	require: false
};
var mocha = {
	after: false,
	afterEach: false,
	before: false,
	beforeEach: false,
	context: false,
	describe: false,
	it: false,
	mocha: false,
	run: false,
	setup: false,
	specify: false,
	suite: false,
	suiteSetup: false,
	suiteTeardown: false,
	teardown: false,
	test: false,
	xcontext: false,
	xdescribe: false,
	xit: false,
	xspecify: false
};
var jasmine = {
	afterAll: false,
	afterEach: false,
	beforeAll: false,
	beforeEach: false,
	describe: false,
	expect: false,
	expectAsync: false,
	fail: false,
	fdescribe: false,
	fit: false,
	it: false,
	jasmine: false,
	pending: false,
	runs: false,
	spyOn: false,
	spyOnAllFunctions: false,
	spyOnProperty: false,
	waits: false,
	waitsFor: false,
	xdescribe: false,
	xit: false
};
var jest = {
	afterAll: false,
	afterEach: false,
	beforeAll: false,
	beforeEach: false,
	describe: false,
	expect: false,
	fit: false,
	it: false,
	jest: false,
	test: false,
	xdescribe: false,
	xit: false,
	xtest: false
};
var qunit = {
	asyncTest: false,
	deepEqual: false,
	equal: false,
	expect: false,
	module: false,
	notDeepEqual: false,
	notEqual: false,
	notOk: false,
	notPropEqual: false,
	notStrictEqual: false,
	ok: false,
	propEqual: false,
	QUnit: false,
	raises: false,
	start: false,
	stop: false,
	strictEqual: false,
	test: false,
	throws: false
};
var phantomjs = {
	console: true,
	exports: true,
	phantom: true,
	require: true,
	WebPage: true
};
var couch = {
	emit: false,
	exports: false,
	getRow: false,
	log: false,
	module: false,
	provides: false,
	require: false,
	respond: false,
	send: false,
	start: false,
	sum: false
};
var rhino = {
	defineClass: false,
	deserialize: false,
	gc: false,
	help: false,
	importClass: false,
	importPackage: false,
	java: false,
	load: false,
	loadClass: false,
	Packages: false,
	print: false,
	quit: false,
	readFile: false,
	readUrl: false,
	runCommand: false,
	seal: false,
	serialize: false,
	spawn: false,
	sync: false,
	toint32: false,
	version: false
};
var nashorn = {
	__DIR__: false,
	__FILE__: false,
	__LINE__: false,
	com: false,
	edu: false,
	exit: false,
	java: false,
	Java: false,
	javafx: false,
	JavaImporter: false,
	javax: false,
	JSAdapter: false,
	load: false,
	loadWithNewGlobal: false,
	org: false,
	Packages: false,
	print: false,
	quit: false
};
var wsh = {
	ActiveXObject: false,
	CollectGarbage: false,
	Debug: false,
	Enumerator: false,
	GetObject: false,
	RuntimeObject: false,
	ScriptEngine: false,
	ScriptEngineBuildVersion: false,
	ScriptEngineMajorVersion: false,
	ScriptEngineMinorVersion: false,
	VBArray: false,
	WScript: false,
	WSH: false
};
var jquery = {
	$: false,
	jQuery: false
};
var yui = {
	YAHOO: false,
	YAHOO_config: false,
	YUI: false,
	YUI_config: false
};
var shelljs = {
	cat: false,
	cd: false,
	chmod: false,
	config: false,
	cp: false,
	dirs: false,
	echo: false,
	env: false,
	error: false,
	exec: false,
	exit: false,
	find: false,
	grep: false,
	head: false,
	ln: false,
	ls: false,
	mkdir: false,
	mv: false,
	popd: false,
	pushd: false,
	pwd: false,
	rm: false,
	sed: false,
	set: false,
	ShellString: false,
	sort: false,
	tail: false,
	tempdir: false,
	test: false,
	touch: false,
	uniq: false,
	which: false
};
var prototypejs = {
	$: false,
	$$: false,
	$A: false,
	$break: false,
	$continue: false,
	$F: false,
	$H: false,
	$R: false,
	$w: false,
	Abstract: false,
	Ajax: false,
	Autocompleter: false,
	Builder: false,
	Class: false,
	Control: false,
	Draggable: false,
	Draggables: false,
	Droppables: false,
	Effect: false,
	Element: false,
	Enumerable: false,
	Event: false,
	Field: false,
	Form: false,
	Hash: false,
	Insertion: false,
	ObjectRange: false,
	PeriodicalExecuter: false,
	Position: false,
	Prototype: false,
	Scriptaculous: false,
	Selector: false,
	Sortable: false,
	SortableObserver: false,
	Sound: false,
	Template: false,
	Toggle: false,
	Try: false
};
var meteor = {
	$: false,
	Accounts: false,
	AccountsClient: false,
	AccountsCommon: false,
	AccountsServer: false,
	App: false,
	Assets: false,
	Blaze: false,
	check: false,
	Cordova: false,
	DDP: false,
	DDPRateLimiter: false,
	DDPServer: false,
	Deps: false,
	EJSON: false,
	Email: false,
	HTTP: false,
	Log: false,
	Match: false,
	Meteor: false,
	Mongo: false,
	MongoInternals: false,
	Npm: false,
	Package: false,
	Plugin: false,
	process: false,
	Random: false,
	ReactiveDict: false,
	ReactiveVar: false,
	Router: false,
	ServiceConfiguration: false,
	Session: false,
	share: false,
	Spacebars: false,
	Template: false,
	Tinytest: false,
	Tracker: false,
	UI: false,
	Utils: false,
	WebApp: false,
	WebAppInternals: false
};
var mongo = {
	_isWindows: false,
	_rand: false,
	BulkWriteResult: false,
	cat: false,
	cd: false,
	connect: false,
	db: false,
	getHostName: false,
	getMemInfo: false,
	hostname: false,
	ISODate: false,
	listFiles: false,
	load: false,
	ls: false,
	md5sumFile: false,
	mkdir: false,
	Mongo: false,
	NumberInt: false,
	NumberLong: false,
	ObjectId: false,
	PlanCache: false,
	print: false,
	printjson: false,
	pwd: false,
	quit: false,
	removeFile: false,
	rs: false,
	sh: false,
	UUID: false,
	version: false,
	WriteResult: false
};
var applescript = {
	$: false,
	Application: false,
	Automation: false,
	console: false,
	delay: false,
	Library: false,
	ObjC: false,
	ObjectSpecifier: false,
	Path: false,
	Progress: false,
	Ref: false
};
var serviceworker = {
	addEventListener: false,
	applicationCache: false,
	atob: false,
	Blob: false,
	BroadcastChannel: false,
	btoa: false,
	ByteLengthQueuingStrategy: false,
	Cache: false,
	caches: false,
	CacheStorage: false,
	clearInterval: false,
	clearTimeout: false,
	Client: false,
	clients: false,
	Clients: false,
	close: true,
	CompressionStream: false,
	console: false,
	CountQueuingStrategy: false,
	crypto: false,
	Crypto: false,
	CryptoKey: false,
	CustomEvent: false,
	DecompressionStream: false,
	ErrorEvent: false,
	Event: false,
	ExtendableEvent: false,
	ExtendableMessageEvent: false,
	fetch: false,
	FetchEvent: false,
	File: false,
	FileReaderSync: false,
	FormData: false,
	Headers: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	ImageData: false,
	importScripts: false,
	indexedDB: false,
	location: false,
	MessageChannel: false,
	MessageEvent: false,
	MessagePort: false,
	name: false,
	navigator: false,
	Notification: false,
	onclose: true,
	onconnect: true,
	onerror: true,
	onfetch: true,
	oninstall: true,
	onlanguagechange: true,
	onmessage: true,
	onmessageerror: true,
	onnotificationclick: true,
	onnotificationclose: true,
	onoffline: true,
	ononline: true,
	onpush: true,
	onpushsubscriptionchange: true,
	onrejectionhandled: true,
	onsync: true,
	onunhandledrejection: true,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceObserver: false,
	PerformanceObserverEntryList: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	postMessage: true,
	queueMicrotask: false,
	ReadableByteStreamController: false,
	ReadableStream: false,
	ReadableStreamBYOBReader: false,
	ReadableStreamBYOBRequest: false,
	ReadableStreamDefaultController: false,
	ReadableStreamDefaultReader: false,
	registration: false,
	removeEventListener: false,
	Request: false,
	Response: false,
	self: false,
	ServiceWorker: false,
	ServiceWorkerContainer: false,
	ServiceWorkerGlobalScope: false,
	ServiceWorkerMessageEvent: false,
	ServiceWorkerRegistration: false,
	setInterval: false,
	setTimeout: false,
	skipWaiting: false,
	SubtleCrypto: false,
	TextDecoder: false,
	TextDecoderStream: false,
	TextEncoder: false,
	TextEncoderStream: false,
	TransformStream: false,
	TransformStreamDefaultController: false,
	URL: false,
	URLSearchParams: false,
	WebAssembly: false,
	WebSocket: false,
	WindowClient: false,
	Worker: false,
	WorkerGlobalScope: false,
	WritableStream: false,
	WritableStreamDefaultController: false,
	WritableStreamDefaultWriter: false,
	XMLHttpRequest: false
};
var atomtest = {
	advanceClock: false,
	atom: false,
	fakeClearInterval: false,
	fakeClearTimeout: false,
	fakeSetInterval: false,
	fakeSetTimeout: false,
	resetTimeouts: false,
	waitsForPromise: false
};
var embertest = {
	andThen: false,
	click: false,
	currentPath: false,
	currentRouteName: false,
	currentURL: false,
	fillIn: false,
	find: false,
	findAll: false,
	findWithAssert: false,
	keyEvent: false,
	pauseTest: false,
	resumeTest: false,
	triggerEvent: false,
	visit: false,
	wait: false
};
var protractor = {
	$: false,
	$$: false,
	browser: false,
	by: false,
	By: false,
	DartObject: false,
	element: false,
	protractor: false
};
var webextensions = {
	browser: false,
	chrome: false,
	opr: false
};
var greasemonkey = {
	cloneInto: false,
	createObjectIn: false,
	exportFunction: false,
	GM: false,
	GM_addElement: false,
	GM_addStyle: false,
	GM_addValueChangeListener: false,
	GM_deleteValue: false,
	GM_download: false,
	GM_getResourceText: false,
	GM_getResourceURL: false,
	GM_getTab: false,
	GM_getTabs: false,
	GM_getValue: false,
	GM_info: false,
	GM_listValues: false,
	GM_log: false,
	GM_notification: false,
	GM_openInTab: false,
	GM_registerMenuCommand: false,
	GM_removeValueChangeListener: false,
	GM_saveTab: false,
	GM_setClipboard: false,
	GM_setValue: false,
	GM_unregisterMenuCommand: false,
	GM_xmlhttpRequest: false,
	unsafeWindow: false
};
var devtools = {
	$: false,
	$_: false,
	$$: false,
	$0: false,
	$1: false,
	$2: false,
	$3: false,
	$4: false,
	$x: false,
	chrome: false,
	clear: false,
	copy: false,
	debug: false,
	dir: false,
	dirxml: false,
	getEventListeners: false,
	inspect: false,
	keys: false,
	monitor: false,
	monitorEvents: false,
	profile: false,
	profileEnd: false,
	queryObjects: false,
	table: false,
	undebug: false,
	unmonitor: false,
	unmonitorEvents: false,
	values: false
};
var globals = {
	builtin: builtin,
	es5: es5,
	es2015: es2015,
	es2017: es2017,
	es2020: es2020,
	es2021: es2021,
	browser: browser,
	worker: worker,
	node: node,
	nodeBuiltin: nodeBuiltin,
	commonjs: commonjs,
	amd: amd,
	mocha: mocha,
	jasmine: jasmine,
	jest: jest,
	qunit: qunit,
	phantomjs: phantomjs,
	couch: couch,
	rhino: rhino,
	nashorn: nashorn,
	wsh: wsh,
	jquery: jquery,
	yui: yui,
	shelljs: shelljs,
	prototypejs: prototypejs,
	meteor: meteor,
	mongo: mongo,
	applescript: applescript,
	serviceworker: serviceworker,
	atomtest: atomtest,
	embertest: embertest,
	protractor: protractor,
	"shared-node-browser": {
	AbortController: false,
	AbortSignal: false,
	atob: false,
	Blob: false,
	BroadcastChannel: false,
	btoa: false,
	ByteLengthQueuingStrategy: false,
	clearInterval: false,
	clearTimeout: false,
	CompressionStream: false,
	console: false,
	CountQueuingStrategy: false,
	crypto: false,
	Crypto: false,
	CryptoKey: false,
	CustomEvent: false,
	DecompressionStream: false,
	DOMException: false,
	Event: false,
	EventTarget: false,
	fetch: false,
	File: false,
	FormData: false,
	Headers: false,
	MessageChannel: false,
	MessageEvent: false,
	MessagePort: false,
	navigator: false,
	Navigator: false,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceObserver: false,
	PerformanceObserverEntryList: false,
	PerformanceResourceTiming: false,
	queueMicrotask: false,
	ReadableByteStreamController: false,
	ReadableStream: false,
	ReadableStreamBYOBReader: false,
	ReadableStreamBYOBRequest: false,
	ReadableStreamDefaultController: false,
	ReadableStreamDefaultReader: false,
	Request: false,
	Response: false,
	setInterval: false,
	setTimeout: false,
	structuredClone: false,
	SubtleCrypto: false,
	TextDecoder: false,
	TextDecoderStream: false,
	TextEncoder: false,
	TextEncoderStream: false,
	TransformStream: false,
	TransformStreamDefaultController: false,
	URL: false,
	URLSearchParams: false,
	WebAssembly: false,
	WritableStream: false,
	WritableStreamDefaultController: false,
	WritableStreamDefaultWriter: false
},
	webextensions: webextensions,
	greasemonkey: greasemonkey,
	devtools: devtools
};

const browserAPIs = ['window', 'document', 'console'];
const builtinAPIs = Object.keys(globals.builtin);

const isIdentifier = (n) => namedTypes.Identifier.check(n);
const isLiteral = (n) => namedTypes.Literal.check(n);
const isExpressionStatement = (n) =>
  namedTypes.ExpressionStatement.check(n);
const isThisExpression = (n) => namedTypes.ThisExpression.check(n);
const isObjectExpression = (n) => namedTypes.ObjectExpression.check(n);
const isThisExpressionStatement = (n) =>
  isExpressionStatement(n) &&
  isMemberExpression(n.expression.left) &&
  isThisExpression(n.expression.left.object);
const isNewExpression = (n) => namedTypes.NewExpression.check(n);
const isSequenceExpression = (n) =>
  namedTypes.SequenceExpression.check(n);
const isExportDefaultStatement = (n) =>
  namedTypes.ExportDefaultDeclaration.check(n);
const isMemberExpression = (n) => namedTypes.MemberExpression.check(n);
const isImportDeclaration = (n) => namedTypes.ImportDeclaration.check(n);
const isTypeAliasDeclaration = (n) =>
  namedTypes.TSTypeAliasDeclaration.check(n);
const isInterfaceDeclaration = (n) =>
  namedTypes.TSInterfaceDeclaration.check(n);
const isExportNamedDeclaration = (n) =>
  namedTypes.ExportNamedDeclaration.check(n);

const isBrowserAPI = ({ name }) => browserAPIs.includes(name);
const isBuiltinAPI = ({ name }) => builtinAPIs.includes(name);
const isRaw = (n) => n && n.raw;

/**
 * True if the node has not expression set nor bindings directives
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only if it's a static node that doesn't need bindings or expressions
 */
function isStaticNode(node) {
  return [
    hasExpressions,
    findEachAttribute,
    findIfAttribute,
    isCustomNode,
    isSlotNode,
  ].every((test) => !test(node))
}

/**
 * Check if a node should be rendered in the final component HTML
 * For example slot <template slot="content"> tags not using `each` or `if` directives can be removed
 * see also https://github.com/riot/riot/issues/2888
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true if we can remove this tag from the component rendered HTML
 */
function isRemovableNode(node) {
  return (
    isTemplateNode(node) &&
    !isNil(findAttribute(SLOT_ATTRIBUTE, node)) &&
    !hasEachAttribute(node) &&
    !hasIfAttribute(node)
  )
}

/**
 * Check if a node name is part of the browser or builtin javascript api or it belongs to the current scope
 * @param   { types.NodePath } path - containing the current node visited
 * @returns {boolean} true if it's a global api variable
 */
function isGlobal({ scope, node }) {
  // recursively find the identifier of this AST path
  if (node.object) {
    return isGlobal({ node: node.object, scope })
  }

  return Boolean(
    isRaw(node) ||
      isBuiltinAPI(node) ||
      isBrowserAPI(node) ||
      isNewExpression(node) ||
      isNodeInScope(scope, node),
  )
}

/**
 * Checks if the identifier of a given node exists in a scope
 * @param {Scope} scope - scope where to search for the identifier
 * @param {types.Node} node - node to search for the identifier
 * @returns {boolean} true if the node identifier is defined in the given scope
 */
function isNodeInScope(scope, node) {
  const traverse = (isInScope = false) => {
    types.visit(node, {
      visitIdentifier(path) {
        if (scope.lookup(getName(path.node))) {
          isInScope = true;
        }

        this.abort();
      },
    });

    return isInScope
  };

  return traverse()
}

/**
 * True if the node has the isCustom attribute set
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true if either it's a riot component or a custom element
 */
function isCustomNode(node) {
  return !!(node[IS_CUSTOM_NODE] || hasIsAttribute(node))
}

/**
 * True the node is <slot>
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true if it's a slot node
 */
function isSlotNode(node) {
  return node.name === SLOT_TAG_NODE_NAME
}

/**
 * True if the node has the isVoid attribute set
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true if the node is self closing
 */
function isVoidNode(node) {
  return !!node[IS_VOID_NODE]
}

/**
 * True if the riot parser did find a tag node
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for the tag nodes
 */
function isTagNode(node) {
  return node.type === nodeTypes.TAG
}

/**
 * True if the riot parser did find a text node
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for the text nodes
 */
function isTextNode(node) {
  return node.type === nodeTypes.TEXT
}

/**
 * True if the node parsed any of the root nodes (each, tag bindings create root nodes as well...)
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for the root nodes
 */
function isRootNode(node) {
  return node.isRoot
}

/**
 * True if the node parsed is the absolute root node (nested root nodes are not considered)
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for the root nodes
 */
function isAbsoluteRootNode(node) {
  return node.isRoot && !node.isNestedRoot
}

/**
 * True if the attribute parsed is of type spread one
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true if the attribute node is of type spread
 */
function isSpreadAttribute(node) {
  return node[IS_SPREAD_ATTRIBUTE]
}

/**
 * True if the node is an attribute and its name is "value"
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for value attribute nodes
 */
function isValueAttribute(node) {
  return node.name === 'value'
}

/**
 * True if the DOM node is a progress tag
 * @param   {RiotParser.Node}  node - riot parser node
 * @returns {boolean} true for the progress tags
 */
function isProgressNode(node) {
  return node.name === PROGRESS_TAG_NODE_NAME
}

/**
 * True if the DOM node is a <template> tag
 * @param   {RiotParser.Node}  node - riot parser node
 * @returns {boolean} true for the progress tags
 */
function isTemplateNode(node) {
  return node.name === TEMPLATE_TAG_NODE_NAME
}

/**
 * True if the node is an attribute and a DOM handler
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for dom listener attribute nodes
 */
const isEventAttribute = (() => {
  const EVENT_ATTR_RE = /^on/;
  return (node) => EVENT_ATTR_RE.test(node.name)
})();

/**
 * Check if a string is an html comment
 * @param   {string}  string - test string
 * @returns {boolean} true if html comment
 */
function isCommentString(string) {
  return string.trim().indexOf('<!') === 0
}

/**
 * True if the node has expressions or expression attributes
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} ditto
 */
function hasExpressions(node) {
  return !!(
    node.expressions ||
    // has expression attributes
    getNodeAttributes(node).some((attribute) => hasExpressions(attribute)) ||
    // has child text nodes with expressions
    (node.nodes &&
      node.nodes.some((node) => isTextNode(node) && hasExpressions(node)))
  )
}

/**
 * True if the node is a directive having its own template
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for the IF EACH and TAG bindings
 */
function hasItsOwnTemplate(node) {
  return [findEachAttribute, findIfAttribute, isCustomNode].some((test) =>
    test(node),
  )
}

const hasIfAttribute = compose(Boolean, findIfAttribute);
const hasEachAttribute = compose(Boolean, findEachAttribute);
const hasIsAttribute = compose(Boolean, findIsAttribute);
compose(Boolean, findKeyAttribute);

/**
 * Find the attribute node
 * @param   { string } name -  name of the attribute we want to find
 * @param   { riotParser.nodeTypes.TAG } node - a tag node
 * @returns { riotParser.nodeTypes.ATTR } attribute node
 */
function findAttribute(name, node) {
  return (
    node.attributes && node.attributes.find((attr) => getName(attr) === name)
  )
}

function findIfAttribute(node) {
  return findAttribute(IF_DIRECTIVE, node)
}

function findEachAttribute(node) {
  return findAttribute(EACH_DIRECTIVE, node)
}

function findKeyAttribute(node) {
  return findAttribute(KEY_ATTRIBUTE, node)
}

function findIsAttribute(node) {
  return findAttribute(IS_DIRECTIVE, node)
}

/**
 * Find all the node attributes that are not expressions
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {Array} list of all the static attributes
 */
function findStaticAttributes(node) {
  return getNodeAttributes(node).filter(
    (attribute) => !hasExpressions(attribute),
  )
}

/**
 * Find all the node attributes that have expressions
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {Array} list of all the dynamic attributes
 */
function findDynamicAttributes(node) {
  return getNodeAttributes(node).filter(hasExpressions)
}

function nullNode() {
  return builders.literal(null)
}

function simplePropertyNode(key, value) {
  const property = builders.property(
    'init',
    builders.identifier(key),
    value,
    false,
  );

  property.sho;
  return property
}

const LINES_RE = /\r\n?|\n/g;

/**
 * Split a string into a rows array generated from its EOL matches
 * @param   { string } string [description]
 * @returns { Array } array containing all the string rows
 */
function splitStringByEOL(string) {
  return string.split(LINES_RE)
}

/**
 * Get the line and the column of a source text based on its position in the string
 * @param   { string } string - target string
 * @param   { number } position - target position
 * @returns { Object } object containing the source text line and column
 */
function getLineAndColumnByPosition(string, position) {
  const lines = splitStringByEOL(string.slice(0, position));

  return {
    line: lines.length,
    column: lines[lines.length - 1].length,
  }
}

/**
 * Add the offset to the code that must be parsed in order to generate properly the sourcemaps
 * @param {string} input - input string
 * @param {string} source - original source code
 * @param {RiotParser.Node} node - node that we are going to transform
 * @return {string} the input string with the offset properly set
 */
function addLineOffset(input, source, node) {
  const { column, line } = getLineAndColumnByPosition(source, node.start);
  return `${'\n'.repeat(line - 1)}${' '.repeat(column + 1)}${input}`
}

/**
 * Create a simple attribute expression
 * @param   {RiotParser.Node.Attr} sourceNode - the custom tag
 * @param   {RiotParser.Node} parentNode - the html node that has received the attribute expression
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @returns {AST.Node} object containing the expression binding keys
 */
function createAttributeExpression(
  sourceNode,
  parentNode,
  sourceFile,
  sourceCode,
) {
  const isSpread = isSpreadAttribute(sourceNode);

  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(EXPRESSION_TYPES),
        builders.identifier(ATTRIBUTE_EXPRESSION_TYPE),
        false,
      ),
    ),
    simplePropertyNode(
      BINDING_IS_BOOLEAN_ATTRIBUTE,
      builders.literal(
        // the hidden attribute is always a boolean and can be applied to any DOM node
        sourceNode.name === 'hidden' ||
          // Custom nodes can't handle boolean attrs
          // Riot.js will handle the bool attrs logic only on native html tags
          (!parentNode[IS_CUSTOM_NODE] &&
            !isAbsoluteRootNode(parentNode) &&
            !isSpread &&
            !!sourceNode[IS_BOOLEAN_ATTRIBUTE]),
      ),
    ),
    simplePropertyNode(
      BINDING_NAME_KEY,
      isSpread ? nullNode() : builders.literal(sourceNode.name),
    ),
    simplePropertyNode(
      BINDING_EVALUATE_KEY,
      createAttributeEvaluationFunction(sourceNode, sourceFile, sourceCode),
    ),
  ])
}

/**
 * Create a simple event expression
 * @param   {RiotParser.Node.Attr} sourceNode - attribute containing the event handlers
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @returns {AST.Node} object containing the expression binding keys
 */
function createEventExpression(
  sourceNode,
  sourceFile,
  sourceCode,
) {
  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(EXPRESSION_TYPES),
        builders.identifier(EVENT_EXPRESSION_TYPE),
        false,
      ),
    ),
    simplePropertyNode(BINDING_NAME_KEY, builders.literal(sourceNode.name)),
    simplePropertyNode(
      BINDING_EVALUATE_KEY,
      createAttributeEvaluationFunction(sourceNode, sourceFile, sourceCode),
    ),
  ])
}

var quot = "\"";
var amp = "&";
var apos = "'";
var lt = "<";
var gt = ">";
var nbsp = " ";
var iexcl = "¡";
var cent = "¢";
var pound = "£";
var curren = "¤";
var yen = "¥";
var brvbar = "¦";
var sect = "§";
var uml = "¨";
var copy = "©";
var ordf = "ª";
var laquo = "«";
var not = "¬";
var shy = "­";
var reg = "®";
var macr = "¯";
var deg = "°";
var plusmn = "±";
var sup2 = "²";
var sup3 = "³";
var acute = "´";
var micro = "µ";
var para = "¶";
var middot = "·";
var cedil = "¸";
var sup1 = "¹";
var ordm = "º";
var raquo = "»";
var frac14 = "¼";
var frac12 = "½";
var frac34 = "¾";
var iquest = "¿";
var Agrave = "À";
var Aacute = "Á";
var Acirc = "Â";
var Atilde = "Ã";
var Auml = "Ä";
var Aring = "Å";
var AElig = "Æ";
var Ccedil = "Ç";
var Egrave = "È";
var Eacute = "É";
var Ecirc = "Ê";
var Euml = "Ë";
var Igrave = "Ì";
var Iacute = "Í";
var Icirc = "Î";
var Iuml = "Ï";
var ETH = "Ð";
var Ntilde = "Ñ";
var Ograve = "Ò";
var Oacute = "Ó";
var Ocirc = "Ô";
var Otilde = "Õ";
var Ouml = "Ö";
var times = "×";
var Oslash = "Ø";
var Ugrave = "Ù";
var Uacute = "Ú";
var Ucirc = "Û";
var Uuml = "Ü";
var Yacute = "Ý";
var THORN = "Þ";
var szlig = "ß";
var agrave = "à";
var aacute = "á";
var acirc = "â";
var atilde = "ã";
var auml = "ä";
var aring = "å";
var aelig = "æ";
var ccedil = "ç";
var egrave = "è";
var eacute = "é";
var ecirc = "ê";
var euml = "ë";
var igrave = "ì";
var iacute = "í";
var icirc = "î";
var iuml = "ï";
var eth = "ð";
var ntilde = "ñ";
var ograve = "ò";
var oacute = "ó";
var ocirc = "ô";
var otilde = "õ";
var ouml = "ö";
var divide = "÷";
var oslash = "ø";
var ugrave = "ù";
var uacute = "ú";
var ucirc = "û";
var uuml = "ü";
var yacute = "ý";
var thorn = "þ";
var yuml = "ÿ";
var OElig = "Œ";
var oelig = "œ";
var Scaron = "Š";
var scaron = "š";
var Yuml = "Ÿ";
var fnof = "ƒ";
var circ = "ˆ";
var tilde = "˜";
var Alpha = "Α";
var Beta = "Β";
var Gamma = "Γ";
var Delta = "Δ";
var Epsilon = "Ε";
var Zeta = "Ζ";
var Eta = "Η";
var Theta = "Θ";
var Iota = "Ι";
var Kappa = "Κ";
var Lambda = "Λ";
var Mu = "Μ";
var Nu = "Ν";
var Xi = "Ξ";
var Omicron = "Ο";
var Pi = "Π";
var Rho = "Ρ";
var Sigma = "Σ";
var Tau = "Τ";
var Upsilon = "Υ";
var Phi = "Φ";
var Chi = "Χ";
var Psi = "Ψ";
var Omega = "Ω";
var alpha = "α";
var beta = "β";
var gamma = "γ";
var delta = "δ";
var epsilon = "ε";
var zeta = "ζ";
var eta = "η";
var theta = "θ";
var iota = "ι";
var kappa = "κ";
var lambda = "λ";
var mu = "μ";
var nu = "ν";
var xi = "ξ";
var omicron = "ο";
var pi = "π";
var rho = "ρ";
var sigmaf = "ς";
var sigma = "σ";
var tau = "τ";
var upsilon = "υ";
var phi = "φ";
var chi = "χ";
var psi = "ψ";
var omega = "ω";
var thetasym = "ϑ";
var upsih = "ϒ";
var piv = "ϖ";
var ensp = " ";
var emsp = " ";
var thinsp = " ";
var zwnj = "‌";
var zwj = "‍";
var lrm = "‎";
var rlm = "‏";
var ndash = "–";
var mdash = "—";
var lsquo = "‘";
var rsquo = "’";
var sbquo = "‚";
var ldquo = "“";
var rdquo = "”";
var bdquo = "„";
var dagger = "†";
var Dagger = "‡";
var bull = "•";
var hellip = "…";
var permil = "‰";
var prime = "′";
var Prime = "″";
var lsaquo = "‹";
var rsaquo = "›";
var oline = "‾";
var frasl = "⁄";
var euro = "€";
var image = "ℑ";
var weierp = "℘";
var real = "ℜ";
var trade = "™";
var alefsym = "ℵ";
var larr = "←";
var uarr = "↑";
var rarr = "→";
var darr = "↓";
var harr = "↔";
var crarr = "↵";
var lArr = "⇐";
var uArr = "⇑";
var rArr = "⇒";
var dArr = "⇓";
var hArr = "⇔";
var forall = "∀";
var part = "∂";
var exist = "∃";
var empty = "∅";
var nabla = "∇";
var isin = "∈";
var notin = "∉";
var ni = "∋";
var prod = "∏";
var sum = "∑";
var minus = "−";
var lowast = "∗";
var radic = "√";
var prop = "∝";
var infin = "∞";
var ang = "∠";
var and = "∧";
var or = "∨";
var cap = "∩";
var cup = "∪";
var int = "∫";
var there4 = "∴";
var sim = "∼";
var cong = "≅";
var asymp = "≈";
var ne = "≠";
var equiv = "≡";
var le = "≤";
var ge = "≥";
var sub = "⊂";
var sup = "⊃";
var nsub = "⊄";
var sube = "⊆";
var supe = "⊇";
var oplus = "⊕";
var otimes = "⊗";
var perp = "⊥";
var sdot = "⋅";
var lceil = "⌈";
var rceil = "⌉";
var lfloor = "⌊";
var rfloor = "⌋";
var lang = "〈";
var rang = "〉";
var loz = "◊";
var spades = "♠";
var clubs = "♣";
var hearts = "♥";
var diams = "♦";
var entities = {
	quot: quot,
	amp: amp,
	apos: apos,
	lt: lt,
	gt: gt,
	nbsp: nbsp,
	iexcl: iexcl,
	cent: cent,
	pound: pound,
	curren: curren,
	yen: yen,
	brvbar: brvbar,
	sect: sect,
	uml: uml,
	copy: copy,
	ordf: ordf,
	laquo: laquo,
	not: not,
	shy: shy,
	reg: reg,
	macr: macr,
	deg: deg,
	plusmn: plusmn,
	sup2: sup2,
	sup3: sup3,
	acute: acute,
	micro: micro,
	para: para,
	middot: middot,
	cedil: cedil,
	sup1: sup1,
	ordm: ordm,
	raquo: raquo,
	frac14: frac14,
	frac12: frac12,
	frac34: frac34,
	iquest: iquest,
	Agrave: Agrave,
	Aacute: Aacute,
	Acirc: Acirc,
	Atilde: Atilde,
	Auml: Auml,
	Aring: Aring,
	AElig: AElig,
	Ccedil: Ccedil,
	Egrave: Egrave,
	Eacute: Eacute,
	Ecirc: Ecirc,
	Euml: Euml,
	Igrave: Igrave,
	Iacute: Iacute,
	Icirc: Icirc,
	Iuml: Iuml,
	ETH: ETH,
	Ntilde: Ntilde,
	Ograve: Ograve,
	Oacute: Oacute,
	Ocirc: Ocirc,
	Otilde: Otilde,
	Ouml: Ouml,
	times: times,
	Oslash: Oslash,
	Ugrave: Ugrave,
	Uacute: Uacute,
	Ucirc: Ucirc,
	Uuml: Uuml,
	Yacute: Yacute,
	THORN: THORN,
	szlig: szlig,
	agrave: agrave,
	aacute: aacute,
	acirc: acirc,
	atilde: atilde,
	auml: auml,
	aring: aring,
	aelig: aelig,
	ccedil: ccedil,
	egrave: egrave,
	eacute: eacute,
	ecirc: ecirc,
	euml: euml,
	igrave: igrave,
	iacute: iacute,
	icirc: icirc,
	iuml: iuml,
	eth: eth,
	ntilde: ntilde,
	ograve: ograve,
	oacute: oacute,
	ocirc: ocirc,
	otilde: otilde,
	ouml: ouml,
	divide: divide,
	oslash: oslash,
	ugrave: ugrave,
	uacute: uacute,
	ucirc: ucirc,
	uuml: uuml,
	yacute: yacute,
	thorn: thorn,
	yuml: yuml,
	OElig: OElig,
	oelig: oelig,
	Scaron: Scaron,
	scaron: scaron,
	Yuml: Yuml,
	fnof: fnof,
	circ: circ,
	tilde: tilde,
	Alpha: Alpha,
	Beta: Beta,
	Gamma: Gamma,
	Delta: Delta,
	Epsilon: Epsilon,
	Zeta: Zeta,
	Eta: Eta,
	Theta: Theta,
	Iota: Iota,
	Kappa: Kappa,
	Lambda: Lambda,
	Mu: Mu,
	Nu: Nu,
	Xi: Xi,
	Omicron: Omicron,
	Pi: Pi,
	Rho: Rho,
	Sigma: Sigma,
	Tau: Tau,
	Upsilon: Upsilon,
	Phi: Phi,
	Chi: Chi,
	Psi: Psi,
	Omega: Omega,
	alpha: alpha,
	beta: beta,
	gamma: gamma,
	delta: delta,
	epsilon: epsilon,
	zeta: zeta,
	eta: eta,
	theta: theta,
	iota: iota,
	kappa: kappa,
	lambda: lambda,
	mu: mu,
	nu: nu,
	xi: xi,
	omicron: omicron,
	pi: pi,
	rho: rho,
	sigmaf: sigmaf,
	sigma: sigma,
	tau: tau,
	upsilon: upsilon,
	phi: phi,
	chi: chi,
	psi: psi,
	omega: omega,
	thetasym: thetasym,
	upsih: upsih,
	piv: piv,
	ensp: ensp,
	emsp: emsp,
	thinsp: thinsp,
	zwnj: zwnj,
	zwj: zwj,
	lrm: lrm,
	rlm: rlm,
	ndash: ndash,
	mdash: mdash,
	lsquo: lsquo,
	rsquo: rsquo,
	sbquo: sbquo,
	ldquo: ldquo,
	rdquo: rdquo,
	bdquo: bdquo,
	dagger: dagger,
	Dagger: Dagger,
	bull: bull,
	hellip: hellip,
	permil: permil,
	prime: prime,
	Prime: Prime,
	lsaquo: lsaquo,
	rsaquo: rsaquo,
	oline: oline,
	frasl: frasl,
	euro: euro,
	image: image,
	weierp: weierp,
	real: real,
	trade: trade,
	alefsym: alefsym,
	larr: larr,
	uarr: uarr,
	rarr: rarr,
	darr: darr,
	harr: harr,
	crarr: crarr,
	lArr: lArr,
	uArr: uArr,
	rArr: rArr,
	dArr: dArr,
	hArr: hArr,
	forall: forall,
	part: part,
	exist: exist,
	empty: empty,
	nabla: nabla,
	isin: isin,
	notin: notin,
	ni: ni,
	prod: prod,
	sum: sum,
	minus: minus,
	lowast: lowast,
	radic: radic,
	prop: prop,
	infin: infin,
	ang: ang,
	and: and,
	or: or,
	cap: cap,
	cup: cup,
	int: int,
	there4: there4,
	sim: sim,
	cong: cong,
	asymp: asymp,
	ne: ne,
	equiv: equiv,
	le: le,
	ge: ge,
	sub: sub,
	sup: sup,
	nsub: nsub,
	sube: sube,
	supe: supe,
	oplus: oplus,
	otimes: otimes,
	perp: perp,
	sdot: sdot,
	lceil: lceil,
	rceil: rceil,
	lfloor: lfloor,
	rfloor: rfloor,
	lang: lang,
	rang: rang,
	loz: loz,
	spades: spades,
	clubs: clubs,
	hearts: hearts,
	diams: diams
};

const HTMLEntityRe = /&(\S+);/g;
const HEX_NUMBER = /^[\da-fA-F]+$/;
const DECIMAL_NUMBER = /^\d+$/;

/**
 * Encode unicode hex html entities like for example &#x222;
 * @param   {string} string - input string
 * @returns {string} encoded string
 */
function encodeHex(string) {
  const hex = string.substr(2);

  return HEX_NUMBER.test(hex) ? String.fromCodePoint(parseInt(hex, 16)) : string
}

/**
 * Encode unicode decimal html entities like for example &#222;
 * @param   {string} string - input string
 * @returns {string} encoded string
 */
function encodeDecimal(string) {
  const nr = string.substr(1);

  return DECIMAL_NUMBER.test(nr)
    ? String.fromCodePoint(parseInt(nr, 10))
    : string
}

/**
 * Encode html entities in strings like &nbsp;
 * @param   {string} string - input string
 * @returns {string} encoded string
 */
function encodeHTMLEntities(string) {
  return string.replace(HTMLEntityRe, (match, entity) => {
    const [firstChar, secondChar] = entity;

    if (firstChar === '#') {
      return secondChar === 'x' ? encodeHex(entity) : encodeDecimal(entity)
    } else {
      return entities[entity] || entity
    }
  })
}

/**
 * Native String.prototype.trimEnd method with fallback to String.prototype.trimRight
 * Edge doesn't support the first one
 * @param   {string} string - input string
 * @returns {string} trimmed output
 */
function trimEnd(string) {
  return (string.trimEnd || string.trimRight).apply(string)
}

/**
 * Native String.prototype.trimStart method with fallback to String.prototype.trimLeft
 * Edge doesn't support the first one
 * @param   {string} string - input string
 * @returns {string} trimmed output
 */
function trimStart(string) {
  return (string.trimStart || string.trimLeft).apply(string)
}

/**
 * Unescape the user escaped chars
 * @param   {string} string - input string
 * @param   {string} char - probably a '{' or anything the user want's to escape
 * @returns {string} cleaned up string
 */
function unescapeChar(string, char) {
  return string.replace(RegExp(`\\\\${char}`, 'gm'), char)
}

/**
 * Generate the pure immutable string chunks from a RiotParser.Node.Text
 * @param   {RiotParser.Node.Text} node - riot parser text node
 * @param   {string} sourceCode sourceCode - source code
 * @returns {Array} array containing the immutable string chunks
 */
function generateLiteralStringChunksFromNode(node, sourceCode) {
  return (
    node.expressions
      .reduce((chunks, expression, index) => {
        const start = index ? node.expressions[index - 1].end : node.start;
        const string = encodeHTMLEntities(
          sourceCode.substring(start, expression.start),
        );

        // trimStart the first string
        chunks.push(index === 0 ? trimStart(string) : string);

        // add the tail to the string
        if (index === node.expressions.length - 1)
          chunks.push(
            encodeHTMLEntities(
              trimEnd(sourceCode.substring(expression.end, node.end)),
            ),
          );

        return chunks
      }, [])
      // comments are not supported here
      .filter((str) => !isCommentString(str))
      .map((str) => (node.unescape ? unescapeChar(str, node.unescape) : str))
  )
}

/**
 * Simple bindings might contain multiple expressions like for example: "{foo} and {bar}"
 * This helper aims to merge them in a template literal if it's necessary
 * @param   {RiotParser.Node} node - riot parser node
 * @param   {string} sourceFile - original tag file
 * @param   {string} sourceCode - original tag source code
 * @returns { Object } a template literal expression object
 */
function mergeNodeExpressions(node, sourceFile, sourceCode) {
  if (node.parts.length === 1)
    return transformExpression(node.expressions[0], sourceFile, sourceCode)

  const pureStringChunks = generateLiteralStringChunksFromNode(node, sourceCode);
  const stringsArray = pureStringChunks
    .reduce((acc, str, index) => {
      const expr = node.expressions[index];

      return [
        ...acc,
        builders.literal(str),
        expr ? transformExpression(expr, sourceFile, sourceCode) : nullNode(),
      ]
    }, [])
    // filter the empty literal expressions
    .filter((expr) => !isLiteral(expr) || expr.value);

  return createArrayString(stringsArray)
}

/**
 * Create a text expression
 * @param   {RiotParser.Node.Text} sourceNode - text node to parse
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @param   {number} childNodeIndex - position of the child text node in its parent children nodes
 * @returns {AST.Node} object containing the expression binding keys
 */
function createTextExpression(
  sourceNode,
  sourceFile,
  sourceCode,
  childNodeIndex,
) {
  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(EXPRESSION_TYPES),
        builders.identifier(TEXT_EXPRESSION_TYPE),
        false,
      ),
    ),
    simplePropertyNode(
      BINDING_CHILD_NODE_INDEX_KEY,
      builders.literal(childNodeIndex),
    ),
    simplePropertyNode(
      BINDING_EVALUATE_KEY,
      wrapASTInFunctionWithScope(
        mergeNodeExpressions(sourceNode, sourceFile, sourceCode),
      ),
    ),
  ])
}

function createValueExpression(
  sourceNode,
  sourceFile,
  sourceCode,
) {
  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(EXPRESSION_TYPES),
        builders.identifier(VALUE_EXPRESSION_TYPE),
        false,
      ),
    ),
    simplePropertyNode(
      BINDING_EVALUATE_KEY,
      createAttributeEvaluationFunction(sourceNode, sourceFile, sourceCode),
    ),
  ])
}

function createExpression(
  sourceNode,
  sourceFile,
  sourceCode,
  childNodeIndex,
  parentNode,
) {
  switch (true) {
    case isTextNode(sourceNode):
      return createTextExpression(sourceNode, sourceFile, sourceCode, childNodeIndex)
    // progress nodes value attributes will be rendered as attributes
    // see https://github.com/riot/compiler/issues/122
    case isValueAttribute(sourceNode) &&
      hasValueAttribute(parentNode.name) &&
      !isProgressNode(parentNode):
      return createValueExpression(sourceNode, sourceFile, sourceCode)
    case isEventAttribute(sourceNode):
      return createEventExpression(sourceNode, sourceFile, sourceCode)
    default:
      return createAttributeExpression(sourceNode, parentNode, sourceFile, sourceCode)
  }
}

/**
 * Create the attribute expressions
 * @param   {RiotParser.Node} sourceNode - any kind of node parsed via riot parser
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @returns {Array} array containing all the attribute expressions
 */
function createAttributeExpressions(sourceNode, sourceFile, sourceCode) {
  return findDynamicAttributes(sourceNode).map((attribute) =>
    createExpression(attribute, sourceFile, sourceCode, 0, sourceNode),
  )
}

/**
 * Parse a js source to generate the AST
 * @param   {string} source - javascript source
 * @param   {Object} options - parser options
 * @returns {AST} AST tree
 */
function generateAST(source, options) {
  return parse(source, {
    parser: {
      parse: (source, opts) =>
        parse$1(source, {
          ...opts,
          ecmaVersion: 'latest',
        }),
    },
    ...options,
  })
}

const scope = builders.identifier(SCOPE);
const getName = (node) => (node && node.name ? node.name : node);

/**
 * Replace the path scope with a member Expression
 * @param   { types.NodePath } path - containing the current node visited
 * @param   { types.Node } property - node we want to prefix with the scope identifier
 * @returns {undefined} this is a void function
 */
function replacePathScope(path, property) {
  // make sure that for the scope injection the extra parenthesis get removed
  removeExtraParenthesis(property);
  path.replace(builders.memberExpression(scope, property, false));
}

/**
 * Change the nodes scope adding the `scope` prefix
 * @param   { types.NodePath } path - containing the current node visited
 * @returns { boolean } return false if we want to stop the tree traversal
 * @context { types.visit }
 */
function updateNodeScope(path) {
  if (!isGlobal(path)) {
    replacePathScope(path, path.node);

    return false
  }

  this.traverse(path);
}

/**
 * Change the scope of the member expressions
 * @param   { types.NodePath } path - containing the current node visited
 * @returns { boolean } return always false because we want to check only the first node object
 */
function visitMemberExpression(path) {
  const traversePathObject = () => this.traverse(path.get('object'));
  const currentObject = path.node.object;

  switch (true) {
    case isGlobal(path):
      if (currentObject.arguments && currentObject.arguments.length) {
        traversePathObject();
      }
      break
    case !path.value.computed && isIdentifier(currentObject):
      replacePathScope(path, path.node);
      break
    default:
      this.traverse(path);
  }

  return false
}

/**
 * Objects properties should be handled a bit differently from the Identifier
 * @param   { types.NodePath } path - containing the current node visited
 * @returns { boolean } return false if we want to stop the tree traversal
 */
function visitObjectProperty(path) {
  const value = path.node.value;
  const isShorthand = path.node.shorthand;

  if (isIdentifier(value) || isMemberExpression(value) || isShorthand) {
    // disable shorthand object properties
    if (isShorthand) path.node.shorthand = false;

    updateNodeScope.call(this, path.get('value'));
  } else {
    this.traverse(path.get('value'));
  }

  return false
}

/**
 * The this expressions should be replaced with the scope
 * @param   { types.NodePath } path - containing the current node visited
 * @returns { boolean|undefined } return false if we want to stop the tree traversal
 */
function visitThisExpression(path) {
  path.replace(scope);
  this.traverse(path);
}

/**
 * Replace the identifiers with the node scope
 * @param   { types.NodePath } path - containing the current node visited
 * @returns { boolean|undefined } return false if we want to stop the tree traversal
 */
function visitIdentifier(path) {
  const parentValue = path.parent.value;

  if (
    (!isMemberExpression(parentValue) &&
      // Esprima seem to behave differently from the default recast ast parser
      // fix for https://github.com/riot/riot/issues/2983
      parentValue.key !== path.node) ||
    parentValue.computed
  ) {
    updateNodeScope.call(this, path);
  }

  return false
}

/**
 * Update the scope of the global nodes
 * @param   { Object } ast - ast program
 * @returns { Object } the ast program with all the global nodes updated
 */
function updateNodesScope(ast) {
  const ignorePath = () => false;

  types.visit(ast, {
    visitIdentifier,
    visitMemberExpression,
    visitObjectProperty,
    visitThisExpression,
    visitClassExpression: ignorePath,
  });

  return ast
}

/**
 * Convert any expression to an AST tree
 * @param   { Object } expression - expression parsed by the riot parser
 * @param   { string } sourceFile - original tag file
 * @param   { string } sourceCode - original tag source code
 * @returns { Object } the ast generated
 */
function createASTFromExpression(expression, sourceFile, sourceCode) {
  const code = sourceFile
    ? addLineOffset(expression.text, sourceCode, expression)
    : expression.text;

  return generateAST(`(${code})`, {
    sourceFileName: sourceFile,
  })
}

/**
 * Create the bindings template property
 * @param   {Array} args - arguments to pass to the template function
 * @returns {ASTNode} a binding template key
 */
function createTemplateProperty(args) {
  return simplePropertyNode(
    BINDING_TEMPLATE_KEY,
    args ? callTemplateFunction(...args) : nullNode(),
  )
}

/**
 * Try to get the expression of an attribute node
 * @param   { RiotParser.Node.Attribute } attribute - riot parser attribute node
 * @returns { RiotParser.Node.Expression } attribute expression value
 */
function getAttributeExpression(attribute) {
  return attribute.expressions
    ? attribute.expressions[0]
    : {
        // if no expression was found try to typecast the attribute value
        ...attribute,
        text: attribute.value,
      }
}

/**
 * Wrap the ast generated in a function call providing the scope argument
 * @param   {Object} ast - function body
 * @returns {FunctionExpresion} function having the scope argument injected
 */
function wrapASTInFunctionWithScope(ast) {
  const fn = builders.arrowFunctionExpression([scope], ast);

  // object expressions need to be wrapped in parentheses
  // recast doesn't allow it
  // see also https://github.com/benjamn/recast/issues/985
  if (isObjectExpression(ast)) {
    // doing a small hack here
    // trying to figure out how the recast printer works internally
    ast.extra = {
      parenthesized: true,
    };
  }

  return fn
}

/**
 * Convert any parser option to a valid template one
 * @param   { RiotParser.Node.Expression } expression - expression parsed by the riot parser
 * @param   { string } sourceFile - original tag file
 * @param   { string } sourceCode - original tag source code
 * @returns { Object } a FunctionExpression object
 *
 * @example
 *  toScopedFunction('foo + bar') // scope.foo + scope.bar
 *
 * @example
 *  toScopedFunction('foo.baz + bar') // scope.foo.baz + scope.bar
 */
function toScopedFunction(expression, sourceFile, sourceCode) {
  return compose(wrapASTInFunctionWithScope, transformExpression)(
    expression,
    sourceFile,
    sourceCode,
  )
}

/**
 * Transform an expression node updating its global scope
 * @param   {RiotParser.Node.Expr} expression - riot parser expression node
 * @param   {string} sourceFile - source file
 * @param   {string} sourceCode - source code
 * @returns {ASTExpression} ast expression generated from the riot parser expression node
 */
function transformExpression(expression, sourceFile, sourceCode) {
  return compose(
    removeExtraParenthesis,
    getExpressionAST,
    updateNodesScope,
    createASTFromExpression,
  )(expression, sourceFile, sourceCode)
}

/**
 * Remove the extra parents from the compiler generated expressions
 * @param  {AST.Expression} expr - ast expression
 * @returns {AST.Expression} program expression output without parenthesis
 */
function removeExtraParenthesis(expr) {
  if (expr.extra) expr.extra.parenthesized = false;

  return expr
}

/**
 * Get the parsed AST expression of riot expression node
 * @param   {AST.Program} sourceAST - raw node parsed
 * @returns {AST.Expression} program expression output
 */
function getExpressionAST(sourceAST) {
  const astBody = sourceAST.program.body;

  return astBody[0] ? astBody[0].expression : astBody
}

/**
 * Create the template call function
 * @param   {Array|string|Node.Literal} template - template string
 * @param   {Array<AST.Nodes>} bindings - template bindings provided as AST nodes
 * @returns {Node.CallExpression} template call expression
 */
function callTemplateFunction(template, bindings) {
  return builders.callExpression(builders.identifier(TEMPLATE_FN), [
    template ? builders.literal(template) : nullNode(),
    bindings ? builders.arrayExpression(bindings) : nullNode(),
  ])
}

/**
 * Create the template wrapper function injecting the dependencies needed to render the component html
 * @param {Array<AST.Nodes>|AST.BlockStatement} body - function body
 * @returns {AST.Node} arrow function expression
 */
const createTemplateDependenciesInjectionWrapper = (body) =>
  builders.arrowFunctionExpression(
    [TEMPLATE_FN, EXPRESSION_TYPES, BINDING_TYPES, GET_COMPONENT_FN].map(
      builders.identifier,
    ),
    body,
  );

/**
 * Convert any DOM attribute into a valid DOM selector useful for the querySelector API
 * @param   { string } attributeName - name of the attribute to query
 * @returns { string } the attribute transformed to a query selector
 */
const attributeNameToDOMQuerySelector = (attributeName) =>
  `[${attributeName}]`;

/**
 * Create the properties to query a DOM node
 * @param   { string } attributeName - attribute name needed to identify a DOM node
 * @returns { Array<AST.Node> } array containing the selector properties needed for the binding
 */
function createSelectorProperties(attributeName) {
  return attributeName
    ? [
        simplePropertyNode(
          BINDING_REDUNDANT_ATTRIBUTE_KEY,
          builders.literal(attributeName),
        ),
        simplePropertyNode(
          BINDING_SELECTOR_KEY,
          compose(
            builders.literal,
            attributeNameToDOMQuerySelector,
          )(attributeName),
        ),
      ]
    : []
}

/**
 * Clone the node filtering out the selector attribute from the attributes list
 * @param   {RiotParser.Node} node - riot parser node
 * @param   {string} selectorAttribute - name of the selector attribute to filter out
 * @returns {RiotParser.Node} the node with the attribute cleaned up
 */
function cloneNodeWithoutSelectorAttribute(node, selectorAttribute) {
  return {
    ...node,
    attributes: getAttributesWithoutSelector(
      getNodeAttributes(node),
      selectorAttribute,
    ),
  }
}

/**
 * Get the node attributes without the selector one
 * @param   {Array<RiotParser.Attr>} attributes - attributes list
 * @param   {string} selectorAttribute - name of the selector attribute to filter out
 * @returns {Array<RiotParser.Attr>} filtered attributes
 */
function getAttributesWithoutSelector(attributes, selectorAttribute) {
  if (selectorAttribute)
    return attributes.filter(
      (attribute) => attribute.name !== selectorAttribute,
    )

  return attributes
}

/**
 * Clean binding or custom attributes
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {Array<RiotParser.Node.Attr>} only the attributes that are not bindings or directives
 */
function cleanAttributes(node) {
  return getNodeAttributes(node).filter(
    (attribute) =>
      ![
        IF_DIRECTIVE,
        EACH_DIRECTIVE,
        KEY_ATTRIBUTE,
        SLOT_ATTRIBUTE,
        IS_DIRECTIVE,
      ].includes(attribute.name),
  )
}

/**
 * Root node factory function needed for the top root nodes and the nested ones
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {RiotParser.Node} root node
 */
function rootNodeFactory(node) {
  return {
    nodes: getChildrenNodes(node),
    isRoot: true,
  }
}

/**
 * Create a root node proxing only its nodes and attributes
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {RiotParser.Node} root node
 */
function createRootNode(node) {
  return {
    ...rootNodeFactory(node),
    attributes: compose(
      // root nodes should always have attribute expressions
      transformStaticAttributesIntoExpressions,
      // root nodes shouldn't have directives
      cleanAttributes,
    )(node),
  }
}

/**
 * Create nested root node. Each and If directives create nested root nodes for example
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {RiotParser.Node} root node
 */
function createNestedRootNode(node) {
  return {
    ...rootNodeFactory(node),
    isNestedRoot: true,
    attributes: cleanAttributes(node),
  }
}

/**
 * Transform the static node attributes into expressions, useful for the root nodes
 * @param   {Array<RiotParser.Node.Attr>} attributes - riot parser node
 * @returns {Array<RiotParser.Node.Attr>} all the attributes received as attribute expressions
 */
function transformStaticAttributesIntoExpressions(attributes) {
  return attributes.map((attribute) => {
    if (attribute.expressions) return attribute

    return {
      ...attribute,
      expressions: [
        {
          start: attribute.valueStart,
          end: attribute.end,
          text: `'${
            attribute.value
              ? attribute.value
              : // boolean attributes should be treated differently
                attribute[IS_BOOLEAN_ATTRIBUTE]
                ? attribute.name
                : ''
          }'`,
        },
      ],
    }
  })
}

/**
 * Get all the child nodes of a RiotParser.Node
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {Array<RiotParser.Node>} all the child nodes found
 */
function getChildrenNodes(node) {
  return node && node.nodes ? node.nodes : []
}

/**
 * Get all the attributes of a riot parser node
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {Array<RiotParser.Node.Attribute>} all the attributes find
 */
function getNodeAttributes(node) {
  return node.attributes ? node.attributes : []
}

/**
 * Create custom tag name function
 * @param   {RiotParser.Node} node - riot parser node
 * @param   {string} sourceFile - original tag file
 * @param   {string} sourceCode - original tag source code
 * @returns {RiotParser.Node.Attr} the node name as expression attribute
 */
function createCustomNodeNameEvaluationFunction(
  node,
  sourceFile,
  sourceCode,
) {
  const isAttribute = findIsAttribute(node);
  const toRawString = (val) => `'${val}'`;

  if (isAttribute) {
    return isAttribute.expressions
      ? wrapASTInFunctionWithScope(
          mergeAttributeExpressions(isAttribute, sourceFile, sourceCode),
        )
      : toScopedFunction(
          {
            ...isAttribute,
            text: toRawString(isAttribute.value),
          },
          sourceFile,
          sourceCode,
        )
  }

  return toScopedFunction(
    { ...node, text: toRawString(getName(node)) },
    sourceFile,
    sourceCode,
  )
}

/**
 * Convert all the node static attributes to strings
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {string} all the node static concatenated as string
 */
function staticAttributesToString(node) {
  return findStaticAttributes(node)
    .map((attribute) =>
      attribute[IS_BOOLEAN_ATTRIBUTE] || !attribute.value
        ? attribute.name
        : `${attribute.name}="${unescapeNode(attribute, 'value').value}"`,
    )
    .join(' ')
}

/**
 * Make sure that node escaped chars will be unescaped
 * @param   {RiotParser.Node} node - riot parser node
 * @param   {string} key - key property to unescape
 * @returns {RiotParser.Node} node with the text property unescaped
 */
function unescapeNode(node, key) {
  if (node.unescape) {
    return {
      ...node,
      [key]: unescapeChar(node[key], node.unescape),
    }
  }

  return node
}

/**
 * Convert a riot parser opening node into a string
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {string} the node as string
 */
function nodeToString(node) {
  const attributes = staticAttributesToString(node);

  switch (true) {
    case isTagNode(node):
      return `<${node.name}${attributes ? ` ${attributes}` : ''}${
        isVoidNode(node) ? '/' : ''
      }>`
    case isTextNode(node):
      return hasExpressions(node)
        ? TEXT_NODE_EXPRESSION_PLACEHOLDER
        : unescapeNode(node, 'text').text
    default:
      return node.text || ''
  }
}

/**
 * Close an html node
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {string} the closing tag of the html tag node passed to this function
 */
function closeTag(node) {
  return node.name ? `</${node.name}>` : ''
}

/**
 * Create a strings array with the `join` call to transform it into a string
 * @param   {Array} stringsArray - array containing all the strings to concatenate
 * @returns {AST.CallExpression} array with a `join` call
 */
function createArrayString(stringsArray) {
  return builders.callExpression(
    builders.memberExpression(
      builders.arrayExpression(stringsArray),
      builders.identifier('join'),
      false,
    ),
    [builders.literal('')],
  )
}

/**
 * Simple expression bindings might contain multiple expressions like for example: "class="{foo} red {bar}""
 * This helper aims to merge them in a template literal if it's necessary
 * @param   {RiotParser.Attr} node - riot parser node
 * @param   {string} sourceFile - original tag file
 * @param   {string} sourceCode - original tag source code
 * @returns { Object } a template literal expression object
 */
function mergeAttributeExpressions(node, sourceFile, sourceCode) {
  if (!node.parts || node.parts.length === 1) {
    return transformExpression(node.expressions[0], sourceFile, sourceCode)
  }
  const stringsArray = [
    ...node.parts.reduce((acc, str) => {
      const expression = node.expressions.find((e) => e.text.trim() === str);

      return [
        ...acc,
        expression
          ? transformExpression(expression, sourceFile, sourceCode)
          : builders.literal(encodeHTMLEntities(str)),
      ]
    }, []),
  ].filter((expr) => !isLiteral(expr) || expr.value);

  return createArrayString(stringsArray)
}

/**
 * Create a selector that will be used to find the node via dom-bindings
 * @param   {number} id - temporary variable that will be increased anytime this function will be called
 * @returns {string} selector attribute needed to bind a riot expression
 */
const createBindingSelector = (function createSelector(id = 0) {
  return () => `${BINDING_SELECTOR_PREFIX}${id++}`
})();

/**
 * Create the AST array containing the attributes to bind to this node
 * @param   { RiotParser.Node.Tag } sourceNode - the custom tag
 * @param   { string } selectorAttribute - attribute needed to select the target node
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns {AST.ArrayExpression} array containing the slot objects
 */
function createBindingAttributes(
  sourceNode,
  selectorAttribute,
  sourceFile,
  sourceCode,
) {
  return builders.arrayExpression([
    ...compose(
      (attributes) =>
        attributes.map((attribute) =>
          createExpression(attribute, sourceFile, sourceCode, 0, sourceNode),
        ),
      (attributes) => attributes.filter(hasExpressions),
      (attributes) =>
        getAttributesWithoutSelector(attributes, selectorAttribute),
      cleanAttributes,
    )(sourceNode),
  ])
}

/**
 * Create an attribute evaluation function
 * @param   {RiotParser.Attr} sourceNode - riot parser node
 * @param   {string} sourceFile - original tag file
 * @param   {string} sourceCode - original tag source code
 * @returns { AST.Node } an AST function expression to evaluate the attribute value
 */
function createAttributeEvaluationFunction(
  sourceNode,
  sourceFile,
  sourceCode,
) {
  return wrapASTInFunctionWithScope(
    mergeAttributeExpressions(sourceNode, sourceFile, sourceCode),
  )
}

/**
 * Return a source map as JSON, it it has not the toJSON method it means it can
 * be used right the way
 * @param   { SourceMapGenerator|Object } map - a sourcemap generator or simply an json object
 * @returns { Object } the source map as JSON
 */
function sourcemapAsJSON(map) {
  if (map && map.toJSON) return map.toJSON()
  return map
}

/**
 * Compose two sourcemaps
 * @param   { SourceMapGenerator } formerMap - original sourcemap
 * @param   { SourceMapGenerator } latterMap - target sourcemap
 * @returns { Object } sourcemap json
 */
function composeSourcemaps(formerMap, latterMap) {
  if (isNode() && formerMap && latterMap && latterMap.mappings) {
    return composeSourceMaps(sourcemapAsJSON(formerMap), sourcemapAsJSON(latterMap))
  } else if (isNode() && formerMap) {
    return sourcemapAsJSON(formerMap)
  }

  return {}
}

/**
 * Create a new sourcemap generator
 * @param   { Object } options - sourcemap options
 * @returns { SourceMapGenerator } SourceMapGenerator instance
 */
function createSourcemap(options) {
  return new SourceMapGenerator(options)
}

const Output = Object.freeze({
  code: '',
  ast: [],
  meta: {},
  map: null,
});

/**
 * Create the right output data result of a parsing
 * @param   { Object } data - output data
 * @param   { string } data.code - code generated
 * @param   { AST } data.ast - ast representing the code
 * @param   { SourceMapGenerator } data.map - source map generated along with the code
 * @param   { Object } meta - compilation meta infomration
 * @returns { Output } output container object
 */
function createOutput(data, meta) {
  const output = {
    ...Output,
    ...data,
    meta,
  };

  if (!output.map && meta && meta.options && meta.options.file)
    return {
      ...output,
      map: createSourcemap({ file: meta.options.file }),
    }

  return output
}

/**
 * Transform the source code received via a compiler function
 * @param   { Function } compiler - function needed to generate the output code
 * @param   { Object } meta - compilation meta information
 * @param   { string } source - source code
 * @returns { Output } output - the result of the compiler
 */
function transform(compiler, meta, source) {
  const result = compiler ? compiler(source, meta) : { code: source };
  return createOutput(result, meta)
}

const postprocessors = new Set();

/**
 * Register a postprocessor that will be used after the parsing and compilation of the riot tags
 * @param { Function } postprocessor - transformer that will receive the output code ans sourcemap
 * @returns { Set } the postprocessors collection
 */
function register$1(postprocessor) {
  if (postprocessors.has(postprocessor)) {
    panic(
      `This postprocessor "${
        postprocessor.name || postprocessor.toString()
      }" was already registered`,
    );
  }

  postprocessors.add(postprocessor);

  return postprocessors
}

/**
 * Exec all the postprocessors in sequence combining the sourcemaps generated
 * @param   { Output } compilerOutput - output generated by the compiler
 * @param   { Object } meta - compiling meta information
 * @returns { Output } object containing output code and source map
 */
function execute$1(compilerOutput, meta) {
  return Array.from(postprocessors).reduce(
    function (acc, postprocessor) {
      const { code, map } = acc;
      const output = postprocessor(code, meta);

      return {
        code: output.code,
        map: composeSourcemaps(map, output.map),
      }
    },
    createOutput(compilerOutput, meta),
  )
}

/**
 * Parsers that can be registered by users to preparse components fragments
 * @type { Object }
 */
const preprocessors = Object.freeze({
  javascript: new Map(),
  css: new Map(),
  template: new Map().set('default', (code) => ({ code })),
});

// throw a processor type error
function preprocessorTypeError(type) {
  panic(
    `No preprocessor of type "${type}" was found, please make sure to use one of these: 'javascript', 'css' or 'template'`,
  );
}

// throw an error if the preprocessor was not registered
function preprocessorNameNotFoundError(name) {
  panic(
    `No preprocessor named "${name}" was found, are you sure you have registered it?'`,
  );
}

/**
 * Register a custom preprocessor
 * @param   { string } type - preprocessor type either 'js', 'css' or 'template'
 * @param   { string } name - unique preprocessor id
 * @param   { Function } preprocessor - preprocessor function
 * @returns { Map } - the preprocessors map
 */
function register(type, name, preprocessor) {
  if (!type)
    panic(
      "Please define the type of preprocessor you want to register 'javascript', 'css' or 'template'",
    );
  if (!name) panic('Please define a name for your preprocessor');
  if (!preprocessor) panic('Please provide a preprocessor function');
  if (!preprocessors[type]) preprocessorTypeError(type);
  if (preprocessors[type].has(name))
    panic(`The preprocessor ${name} was already registered before`);

  preprocessors[type].set(name, preprocessor);

  return preprocessors
}

/**
 * Exec the compilation of a preprocessor
 * @param   { string } type - preprocessor type either 'js', 'css' or 'template'
 * @param   { string } name - unique preprocessor id
 * @param   { Object } meta - preprocessor meta information
 * @param   { string } source - source code
 * @returns { Output } object containing a sourcemap and a code string
 */
function execute(type, name, meta, source) {
  if (!preprocessors[type]) preprocessorTypeError(type);
  if (!preprocessors[type].has(name)) preprocessorNameNotFoundError(name);

  return transform(preprocessors[type].get(name), meta, source)
}

/**
 * Simple clone deep function, do not use it for classes or recursive objects!
 * @param   {*} source - possibily an object to clone
 * @returns {*} the object we wanted to clone
 */
function cloneDeep(source) {
  return JSON.parse(JSON.stringify(source))
}

/**
 * Generate the javascript from an ast source
 * @param   {AST} ast - ast object
 * @param   {Object} options - printer options
 * @returns {Object} code + map
 */
function generateJavascript(ast, options) {
  return print(ast, {
    ...options,
    parser: {
      parse: (source, opts) =>
        parse$1(source, {
          ...opts,
          ecmaVersion: 'latest',
        }),
    },
    tabWidth: 2,
    wrapColumn: 0,
    quote: 'single',
  })
}

const getEachItemName = (expression) =>
  isSequenceExpression(expression.left)
    ? expression.left.expressions[0]
    : expression.left;
const getEachIndexName = (expression) =>
  isSequenceExpression(expression.left) ? expression.left.expressions[1] : null;
const getEachValue = (expression) => expression.right;
const nameToliteral = compose(builders.literal, getName);

const generateEachItemNameKey = (expression) =>
  simplePropertyNode(
    BINDING_ITEM_NAME_KEY,
    compose(nameToliteral, getEachItemName)(expression),
  );

const generateEachIndexNameKey = (expression) =>
  simplePropertyNode(
    BINDING_INDEX_NAME_KEY,
    compose(nameToliteral, getEachIndexName)(expression),
  );

const generateEachEvaluateKey = (
  expression,
  eachExpression,
  sourceFile,
  sourceCode,
) =>
  simplePropertyNode(
    BINDING_EVALUATE_KEY,
    compose(
      (e) => toScopedFunction(e, sourceFile, sourceCode),
      (e) => ({
        ...eachExpression,
        text: generateJavascript(e).code,
      }),
      getEachValue,
    )(expression),
  );

/**
 * Get the each expression properties to create properly the template binding
 * @param   { DomBinding.Expression } eachExpression - original each expression data
 * @param   { string } sourceFile - original tag file
 * @param   { string } sourceCode - original tag source code
 * @returns { Array } AST nodes that are needed to build an each binding
 */
function generateEachExpressionProperties(
  eachExpression,
  sourceFile,
  sourceCode,
) {
  const ast = createASTFromExpression(eachExpression, sourceFile, sourceCode);
  const body = ast.program.body;
  const firstNode = body[0];

  if (!isExpressionStatement(firstNode)) {
    panic(
      `The each directives supported should be of type "ExpressionStatement",you have provided a "${firstNode.type}"`,
    );
  }

  const { expression } = firstNode;

  return [
    generateEachItemNameKey(expression),
    generateEachIndexNameKey(expression),
    generateEachEvaluateKey(expression, eachExpression, sourceFile, sourceCode),
  ]
}

/**
 * Transform a RiotParser.Node.Tag into an each binding
 * @param   { RiotParser.Node.Tag } sourceNode - tag containing the each attribute
 * @param   { string } selectorAttribute - attribute needed to select the target node
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns { AST.Node } an each binding node
 */
function createEachBinding(
  sourceNode,
  selectorAttribute,
  sourceFile,
  sourceCode,
) {
  const [ifAttribute, eachAttribute, keyAttribute] = [
    findIfAttribute,
    findEachAttribute,
    findKeyAttribute,
  ].map((f) => f(sourceNode));
  const attributeOrNull = (attribute) =>
    attribute
      ? toScopedFunction(
          getAttributeExpression(attribute),
          sourceFile,
          sourceCode,
        )
      : nullNode();

  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(BINDING_TYPES),
        builders.identifier(EACH_BINDING_TYPE),
        false,
      ),
    ),
    simplePropertyNode(BINDING_GET_KEY_KEY, attributeOrNull(keyAttribute)),
    simplePropertyNode(BINDING_CONDITION_KEY, attributeOrNull(ifAttribute)),
    createTemplateProperty(
      createNestedBindings(
        sourceNode,
        sourceFile,
        sourceCode,
        selectorAttribute,
      ),
    ),
    ...createSelectorProperties(selectorAttribute),
    ...compose(
      generateEachExpressionProperties,
      getAttributeExpression,
    )(eachAttribute),
  ])
}

/**
 * Transform a RiotParser.Node.Tag into an if binding
 * @param   { RiotParser.Node.Tag } sourceNode - tag containing the if attribute
 * @param   { string } selectorAttribute - attribute needed to select the target node
 * @param   { stiring } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns { AST.Node } an if binding node
 */
function createIfBinding(
  sourceNode,
  selectorAttribute,
  sourceFile,
  sourceCode,
) {
  const ifAttribute = findIfAttribute(sourceNode);

  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(BINDING_TYPES),
        builders.identifier(IF_BINDING_TYPE),
        false,
      ),
    ),
    simplePropertyNode(
      BINDING_EVALUATE_KEY,
      toScopedFunction(ifAttribute.expressions[0], sourceFile, sourceCode),
    ),
    ...createSelectorProperties(selectorAttribute),
    createTemplateProperty(
      createNestedBindings(
        sourceNode,
        sourceFile,
        sourceCode,
        selectorAttribute,
      ),
    ),
  ])
}

/**
 * Create the text node expressions
 * @param   {RiotParser.Node} sourceNode - any kind of node parsed via riot parser
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @returns {Array} array containing all the text node expressions
 */
function createTextNodeExpressions(sourceNode, sourceFile, sourceCode) {
  const childrenNodes = getChildrenNodes(sourceNode);

  return childrenNodes
    .filter(isTextNode)
    .filter(hasExpressions)
    .map((node) =>
      createExpression(
        node,
        sourceFile,
        sourceCode,
        childrenNodes.indexOf(node),
        sourceNode,
      ),
    )
}

/**
 * Add a simple binding to a riot parser node
 * @param   { RiotParser.Node.Tag } sourceNode - tag containing the if attribute
 * @param   { string } selectorAttribute - attribute needed to select the target node
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns { AST.Node } an each binding node
 */
function createSimpleBinding(
  sourceNode,
  selectorAttribute,
  sourceFile,
  sourceCode,
) {
  return builders.objectExpression([
    // root or removable nodes do not need selectors
    ...(isRemovableNode(sourceNode) || isRootNode(sourceNode)
      ? []
      : createSelectorProperties(selectorAttribute)),
    simplePropertyNode(
      BINDING_EXPRESSIONS_KEY,
      builders.arrayExpression([
        ...createTextNodeExpressions(sourceNode, sourceFile, sourceCode),
        ...createAttributeExpressions(sourceNode, sourceFile, sourceCode),
      ]),
    ),
  ])
}

/**
 * Transform a RiotParser.Node.Tag of type slot into a slot binding
 * @param   { RiotParser.Node.Tag } sourceNode - slot node
 * @param   { string } selectorAttribute - attribute needed to select the target node
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns { AST.Node } a slot binding node
 */
function createSlotBinding(
  sourceNode,
  selectorAttribute,
  sourceFile,
  sourceCode,
) {
  const slotNameAttribute = findAttribute(NAME_ATTRIBUTE, sourceNode);
  const slotName = slotNameAttribute
    ? slotNameAttribute.value
    : DEFAULT_SLOT_NAME;

  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(BINDING_TYPES),
        builders.identifier(SLOT_BINDING_TYPE),
        false,
      ),
    ),
    simplePropertyNode(
      BINDING_ATTRIBUTES_KEY,
      createBindingAttributes(
        {
          ...sourceNode,
          // filter the name attribute
          attributes: getNodeAttributes(sourceNode).filter(
            (attribute) => getName(attribute) !== NAME_ATTRIBUTE,
          ),
        },
        selectorAttribute,
        sourceFile,
        sourceCode,
      ),
    ),
    simplePropertyNode(BINDING_NAME_KEY, builders.literal(slotName)),
    ...createSelectorProperties(selectorAttribute),
  ])
}

/**
 * Find the slots in the current component and group them under the same id
 * @param   {RiotParser.Node.Tag} sourceNode - the custom tag
 * @returns {Object} object containing all the slots grouped by name
 */
function groupSlots(sourceNode) {
  return getChildrenNodes(sourceNode).reduce(
    (acc, node) => {
      const slotAttribute = findSlotAttribute(node);

      if (slotAttribute) {
        acc[slotAttribute.value] = node;
      } else {
        acc.default = createNestedRootNode({
          nodes: [...getChildrenNodes(acc.default), node],
        });
      }

      return acc
    },
    {
      default: null,
    },
  )
}

/**
 * Create the slot entity to pass to the riot-dom bindings
 * @param   {string} id - slot id
 * @param   {RiotParser.Node.Tag} sourceNode - slot root node
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @returns {AST.Node} ast node containing the slot object properties
 */
function buildSlot(id, sourceNode, sourceFile, sourceCode) {
  const cloneNode = {
    ...sourceNode,
    attributes: getNodeAttributes(sourceNode),
  };
  const [html, bindings] = build(cloneNode, sourceFile, sourceCode);

  return builders.objectExpression([
    simplePropertyNode(BINDING_ID_KEY, builders.literal(id)),
    simplePropertyNode(BINDING_HTML_KEY, builders.literal(html)),
    simplePropertyNode(
      BINDING_BINDINGS_KEY,
      builders.arrayExpression(bindings),
    ),
  ])
}

/**
 * Create the AST array containing the slots
 * @param   { RiotParser.Node.Tag } sourceNode - the custom tag
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns {AST.ArrayExpression} array containing the attributes to bind
 */
function createSlotsArray(sourceNode, sourceFile, sourceCode) {
  return builders.arrayExpression([
    ...compose(
      (slots) =>
        slots.map(([key, value]) =>
          buildSlot(key, value, sourceFile, sourceCode),
        ),
      (slots) => slots.filter(([, value]) => value),
      Object.entries,
      groupSlots,
    )(sourceNode),
  ])
}

/**
 * Find the slot attribute if it exists
 * @param   {RiotParser.Node.Tag} sourceNode - the custom tag
 * @returns {RiotParser.Node.Attr|undefined} the slot attribute found
 */
function findSlotAttribute(sourceNode) {
  return getNodeAttributes(sourceNode).find(
    (attribute) => attribute.name === SLOT_ATTRIBUTE,
  )
}

/**
 * Transform a RiotParser.Node.Tag into a tag binding
 * @param   { RiotParser.Node.Tag } sourceNode - the custom tag
 * @param   { string } selectorAttribute - attribute needed to select the target node
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns { AST.Node } tag binding node
 */
function createTagBinding(
  sourceNode,
  selectorAttribute,
  sourceFile,
  sourceCode,
) {
  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(BINDING_TYPES),
        builders.identifier(TAG_BINDING_TYPE),
        false,
      ),
    ),
    simplePropertyNode(
      BINDING_GET_COMPONENT_KEY,
      builders.identifier(GET_COMPONENT_FN),
    ),
    simplePropertyNode(
      BINDING_EVALUATE_KEY,
      createCustomNodeNameEvaluationFunction(
        sourceNode,
        sourceFile,
        sourceCode,
      ),
    ),
    simplePropertyNode(
      BINDING_SLOTS_KEY,
      createSlotsArray(sourceNode, sourceFile, sourceCode),
    ),
    simplePropertyNode(
      BINDING_ATTRIBUTES_KEY,
      createBindingAttributes(
        sourceNode,
        selectorAttribute,
        sourceFile,
        sourceCode,
      ),
    ),
    ...createSelectorProperties(selectorAttribute),
  ])
}

const BuildingState = Object.freeze({
  html: [],
  bindings: [],
  parent: null,
});

/**
 * Nodes having bindings should be cloned and new selector properties should be added to them
 * @param   {RiotParser.Node} sourceNode - any kind of node parsed via riot parser
 * @param   {string} bindingsSelector - temporary string to identify the current node
 * @returns {RiotParser.Node} the original node parsed having the new binding selector attribute
 */
function createBindingsTag(sourceNode, bindingsSelector) {
  if (!bindingsSelector) return sourceNode

  return {
    ...sourceNode,
    // inject the selector bindings into the node attributes
    attributes: [
      {
        name: bindingsSelector,
        value: bindingsSelector,
      },
      ...getNodeAttributes(sourceNode),
    ],
  }
}

/**
 * Create a generic dynamic node (text or tag) and generate its bindings
 * @param   {RiotParser.Node} sourceNode - any kind of node parsed via riot parser
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @param   {BuildingState} state - state representing the current building tree state during the recursion
 * @returns {Array} array containing the html output and bindings for the current node
 */
function createDynamicNode(sourceNode, sourceFile, sourceCode, state) {
  switch (true) {
    case isTextNode(sourceNode):
      // text nodes will not have any bindings
      return [nodeToString(sourceNode), []]
    default:
      return createTagWithBindings(sourceNode, sourceFile, sourceCode)
  }
}

/**
 * Create only a dynamic tag node with generating a custom selector and its bindings
 * @param   {RiotParser.Node} sourceNode - any kind of node parsed via riot parser
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @param   {BuildingState} state - state representing the current building tree state during the recursion
 * @returns {Array} array containing the html output and bindings for the current node
 */
function createTagWithBindings(sourceNode, sourceFile, sourceCode) {
  const bindingsSelector = isRootNode(sourceNode)
    ? null
    : createBindingSelector();
  const cloneNode = createBindingsTag(sourceNode, bindingsSelector);
  const tagOpeningHTML = nodeToString(cloneNode);

  switch (true) {
    case hasEachAttribute(cloneNode):
      // EACH bindings have prio 1
      return [
        tagOpeningHTML,
        [createEachBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)],
      ]
    case hasIfAttribute(cloneNode):
      // IF bindings have prio 2
      return [
        tagOpeningHTML,
        [createIfBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)],
      ]
    case isCustomNode(cloneNode):
      // TAG bindings have prio 3
      return [
        tagOpeningHTML,
        [createTagBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)],
      ]
    case isSlotNode(cloneNode):
      // slot tag
      return [tagOpeningHTML, [createSlotBinding(cloneNode, bindingsSelector)]]
    default:
      // this node has expressions bound to it
      return [
        tagOpeningHTML,
        [createSimpleBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)],
      ]
  }
}

/**
 * Parse a node trying to extract its template and bindings
 * @param   {RiotParser.Node} sourceNode - any kind of node parsed via riot parser
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @param   {BuildingState} state - state representing the current building tree state during the recursion
 * @returns {Array} array containing the html output and bindings for the current node
 */
function parseNode(sourceNode, sourceFile, sourceCode, state) {
  // static nodes have no bindings
  if (isStaticNode(sourceNode)) return [nodeToString(sourceNode), []]
  return createDynamicNode(sourceNode, sourceFile, sourceCode)
}

/**
 * Create the tag binding
 * @param   { RiotParser.Node.Tag } sourceNode - tag containing the each attribute
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @param   { string } selector - binding selector
 * @returns { Array } array with only the tag binding AST
 */
function createNestedBindings(
  sourceNode,
  sourceFile,
  sourceCode,
  selector,
) {
  const mightBeARiotComponent = isCustomNode(sourceNode);
  const node = cloneNodeWithoutSelectorAttribute(sourceNode, selector);

  return mightBeARiotComponent
    ? [null, [createTagBinding(node, null, sourceFile, sourceCode)]]
    : build(createNestedRootNode(node), sourceFile, sourceCode)
}

/**
 * Build the template and the bindings
 * @param   {RiotParser.Node} sourceNode - any kind of node parsed via riot parser
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @param   {BuildingState} state - state representing the current building tree state during the recursion
 * @returns {Array} array containing the html output and the dom bindings
 */
function build(sourceNode, sourceFile, sourceCode, state) {
  if (!sourceNode)
    panic(
      "Something went wrong with your tag DOM parsing, your tag template can't be created",
    );

  const [nodeHTML, nodeBindings] = parseNode(
    sourceNode,
    sourceFile,
    sourceCode);
  const childrenNodes = getChildrenNodes(sourceNode);
  const canRenderNodeHTML = isRemovableNode(sourceNode) === false;
  const currentState = { ...cloneDeep(BuildingState), ...state };

  // mutate the original arrays
  canRenderNodeHTML && currentState.html.push(...nodeHTML);
  currentState.bindings.push(...nodeBindings);

  // do recursion if
  // this tag has children and it has no special directives bound to it
  if (childrenNodes.length && !hasItsOwnTemplate(sourceNode)) {
    childrenNodes.forEach((node) =>
      build(node, sourceFile, sourceCode, {
        parent: sourceNode,
        ...currentState,
      }),
    );
  }

  // close the tag if it's not a void one
  if (canRenderNodeHTML && isTagNode(sourceNode) && !isVoidNode(sourceNode)) {
    currentState.html.push(closeTag(sourceNode));
  }

  return [currentState.html.join(''), currentState.bindings]
}

const ATTRIBUTE_TYPE_NAME = 'type';

/**
 * Get the type attribute from a node generated by the riot parser
 * @param   { Object} sourceNode - riot parser node
 * @returns { string|null } a valid type to identify the preprocessor to use or nothing
 */
function getPreprocessorTypeByAttribute(sourceNode) {
  const typeAttribute = sourceNode.attributes
    ? sourceNode.attributes.find(
        (attribute) => attribute.name === ATTRIBUTE_TYPE_NAME,
      )
    : null;

  return typeAttribute ? normalize(typeAttribute.value) : null
}

/**
 * Remove the noise in case a user has defined the preprocessor type='text/scss'
 * @param   { string } value - input string
 * @returns { string } normalized string
 */
function normalize(value) {
  return value.replace('text/', '')
}

/**
 * Preprocess a riot parser node
 * @param   { string } preprocessorType - either css, js
 * @param   { string } preprocessorName - preprocessor id
 * @param   { Object } meta - compilation meta information
 * @param   { RiotParser.nodeTypes } node - css node detected by the parser
 * @returns { Output } code and sourcemap generated by the preprocessor
 */
function preprocess(
  preprocessorType,
  preprocessorName,
  meta,
  node,
) {
  const code = node.text;

  return preprocessorName
    ? execute(preprocessorType, preprocessorName, meta, code)
    : { code }
}

const HOST = ':host';
const DISABLED_SELECTORS = ['from', 'to'];

/**
 * Matches valid, multiline JavaScript comments in almost all its forms.
 * @const {RegExp}
 * @static
 */
const R_MLCOMMS = /\/\*[^*]*\*+(?:[^*/][^*]*\*+)*\//g;

/**
 * Source for creating regexes matching valid quoted, single-line JavaScript strings.
 * It recognizes escape characters, including nested quotes and line continuation.
 * @const {string}
 */
const S_LINESTR =
  /"[^"\n\\]*(?:\\[\S\s][^"\n\\]*)*"|'[^'\n\\]*(?:\\[\S\s][^'\n\\]*)*'/.source;

/**
 * Matches CSS selectors, excluding those beginning with '@' and quoted strings.
 * @const {RegExp}
 */

const CSS_SELECTOR = RegExp(
  `([{}]|^)[; ]*((?:[^@ ;{}][^{}]*)?[^@ ;{}:] ?)(?={)|${S_LINESTR}`,
  'g',
);

/**
 * Matches the list of css selectors excluding the pseudo selectors
 * @const {RegExp}
 */

const CSS_SELECTOR_LIST =
  /([^,]+)(?::(?!host)\w+(?:[\s|\S]*?\))?(?:[^,:]*)?)+|([^,]+)/g;

/**
 * Scope the css selectors prefixing them with the tag name
 * @param {string} tag - Tag name of the root element
 * @param {string} selectorList - list of selectors we need to scope
 * @returns {string} scoped selectors
 */
function addScopeToSelectorList(tag, selectorList) {
  return selectorList.replace(CSS_SELECTOR_LIST, (match, selector) => {
    const trimmedMatch = match.trim();
    const trimmedSelector = selector ? selector.trim() : trimmedMatch;

    // skip selectors already using the tag name
    if (trimmedSelector.indexOf(tag) === 0) {
      return match
    }

    // skips the keywords and percents of css animations
    if (
      !trimmedSelector ||
      DISABLED_SELECTORS.indexOf(trimmedSelector) > -1 ||
      trimmedSelector.slice(-1) === '%'
    ) {
      return match
    }

    // replace the `:host` pseudo-selector, where it is, with the root tag name;
    // if `:host` was not included, add the tag name as prefix, and mirror all `[is]`
    if (trimmedMatch.indexOf(HOST) < 0) {
      return `${tag} ${trimmedMatch},[is="${tag}"] ${trimmedMatch}`
    } else {
      return `${trimmedMatch.replace(HOST, tag)},${trimmedMatch.replace(
        HOST,
        `[is="${tag}"]`,
      )}`
    }
  })
}

/**
 * Parses styles enclosed in a "scoped" tag
 * The "css" string is received without comments or surrounding spaces.
 *
 * @param   {string} tag - Tag name of the root element
 * @param   {string} css - The CSS code
 * @returns {string} CSS with the styles scoped to the root element
 */
function generateScopedCss(tag, css) {
  return css.replace(CSS_SELECTOR, function (m, cssChunk, selectorList) {
    // skip quoted strings
    if (!selectorList) return m

    // we have a selector list, parse each individually
    const scopedSelectorList = addScopeToSelectorList(tag, selectorList);

    // add the danling bracket char and return the processed selector list
    return cssChunk ? `${cssChunk} ${scopedSelectorList}` : scopedSelectorList
  })
}

/**
 * Remove comments, compact and trim whitespace
 * @param { string } code - compiled css code
 * @returns { string } css code normalized
 */
function compactCss(code) {
  return code.replace(R_MLCOMMS, '').replace(/\s+/g, ' ').trim()
}

const escapeBackslashes = (s) => s.replace(/\\/g, '\\\\');
const escapeIdentifier = (identifier) =>
  escapeBackslashes(
    cssEscape(identifier, {
      isIdentifier: true,
    }),
  );

/**
 * Generate the component css
 * @param   { Object } sourceNode - node generated by the riot compiler
 * @param   { string } source - original component source code
 * @param   { Object } meta - compilation meta information
 * @param   { AST } ast - current AST output
 * @returns { AST } the AST generated
 */
function css(sourceNode, source, meta, ast) {
  const preprocessorName = getPreprocessorTypeByAttribute(sourceNode);
  const { options } = meta;
  const preprocessorOutput = preprocess(
    'css',
    preprocessorName,
    meta,
    sourceNode.text,
  );
  const normalizedCssCode = compactCss(preprocessorOutput.code);
  const escapedCssIdentifier = escapeIdentifier(meta.tagName);

  const cssCode = (
    options.scopedCss
      ? generateScopedCss(
          escapedCssIdentifier,
          escapeBackslashes(normalizedCssCode),
        )
      : escapeBackslashes(normalizedCssCode)
  ).trim();

  types.visit(ast, {
    visitProperty(path) {
      if (path.value.key.name === TAG_CSS_PROPERTY) {
        path.value.value = builders.templateLiteral(
          [builders.templateElement({ raw: cssCode, cooked: '' }, false)],
          [],
        );

        return false
      }

      this.traverse(path);
    },
  });

  return ast
}

/**
 * Find whether there is html code outside of the root node
 * @param   {RiotParser.Node} root - node generated by the riot compiler
 * @param   {string}  code - riot tag source code
 * @param   {Function} parse - riot parser function
 * @returns {boolean} true if extra markup is detected
 */
function hasHTMLOutsideRootNode(root, code, parse) {
  const additionalCode = root
    ? [
        // head
        code.substr(0, root.start),
        // tail
        code.substr(root.end, code.length),
      ]
        .join('')
        .trim()
    : '';

  if (additionalCode) {
    // if there are parsing errors we assume that there are no html
    // tags outside of the root node
    try {
      const { template, javascript, css } = parse(additionalCode).output;

      return [template, javascript, css].some(isObject)
    } catch (error) {
      return false
    }
  }

  return false
}

/**
 * Ckeck if an Array-like object has empty length
 * @param {Array} target - Array-like object
 * @returns {boolean} target is empty or null
 */
function isEmptyArray(target) {
  return !target || !target.length
}

/**
 * True if the sourcemap has no mappings, it is empty
 * @param   {Object}  map - sourcemap json
 * @returns {boolean} true if empty
 */
function isEmptySourcemap(map) {
  return !map || isEmptyArray(map.mappings)
}

/**
 * Find the export default statement
 * @param   { Array } body - tree structure containing the program code
 * @returns { Object } node containing only the code of the export default statement
 */
function findExportDefaultStatement(body) {
  return body.find(isExportDefaultStatement)
}

/**
 * Find all import declarations
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } array containing all the import declarations detected
 */
function findAllImportDeclarations(body) {
  return body.filter(isImportDeclaration)
}

/**
 * Find all the named export declarations
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } array containing all the named export declarations detected
 */
function findAllExportNamedDeclarations(body) {
  return body.filter(isExportNamedDeclaration)
}

/**
 * Filter all the import declarations
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } array containing all the ast expressions without the import declarations
 */
function filterOutAllImportDeclarations(body) {
  return body.filter((n) => !isImportDeclaration(n))
}

/**
 * Filter all the export declarations
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } array containing all the ast expressions without the export declarations
 */
function filterOutAllExportDeclarations(body) {
  return body.filter(
    (n) => !isExportNamedDeclaration(n) || isExportDefaultStatement(n),
  )
}

/**
 * Find the component interface exported
 * @param   { Array } body - tree structure containing the program code
 * @returns { Object|null } the object referencing the component interface if found
 */
function findComponentInterface(body) {
  const exportNamedDeclarations = body
    .filter(isExportNamedDeclaration)
    .map((n) => n.declaration);
  const types = exportNamedDeclarations.filter(isTypeAliasDeclaration);
  const interfaces = exportNamedDeclarations.filter(isInterfaceDeclaration);
  const isRiotComponentTypeName = ({ typeName }) =>
    typeName && typeName.name
      ? typeName.name === RIOT_TAG_INTERFACE_NAME
      : false;
  const extendsRiotComponent = ({ expression }) =>
    expression.name === RIOT_TAG_INTERFACE_NAME;

  return (
    types.find(
      (node) =>
        (node.typeAnnotation.types &&
          node.typeAnnotation.types.some(isRiotComponentTypeName)) ||
        isRiotComponentTypeName(node.typeAnnotation),
    ) ||
    interfaces.find(
      (node) => node.extends && node.extends.some(extendsRiotComponent),
    )
  )
}

/**
 * Add the component interface to the export declaration
 * @param   { Object } ast - ast object generated by recast
 * @param   { Object } componentInterface - the component typescript interface
 * @returns { Object } the component object exported combined with the riot typescript interfaces
 */
function addComponentInterfaceToExportedObject(ast, componentInterface) {
  const body = getProgramBody(ast);
  const RiotComponentWrapperImportSpecifier = builders.importSpecifier(
    builders.identifier(RIOT_INTERFACE_WRAPPER_NAME),
  );
  const componentInterfaceName = componentInterface.id.name;
  const riotImportDeclaration = findAllImportDeclarations(body).find(
    (node) => node.source.value === RIOT_MODULE_ID,
  );
  const exportDefaultStatement = body.find(isExportDefaultStatement);
  const objectExport = exportDefaultStatement.declaration;

  // add the RiotComponentWrapper to this component imports
  if (riotImportDeclaration) {
    riotImportDeclaration.specifiers.push(RiotComponentWrapperImportSpecifier);
  } else {
    // otherwise create the whole import statement from riot
    body.unshift(
      0,
      builders.importDeclaration(
        [RiotComponentWrapperImportSpecifier],
        builders.stringLiteral(RIOT_MODULE_ID),
      ),
    );
  }

  // override the object export adding the types detected
  exportDefaultStatement.declaration = builders.tsAsExpression(
    objectExport,
    builders.tsTypeReference(
      builders.identifier(RIOT_INTERFACE_WRAPPER_NAME),
      builders.tsTypeParameterInstantiation([
        builders.tsTypeReference(builders.identifier(componentInterfaceName)),
      ]),
    ),
  );

  return ast
}

/**
 * Create the default export declaration interpreting the old riot syntax relying on "this" statements
 * @param   { Array } body - tree structure containing the program code
 * @returns { Object } ExportDefaultDeclaration
 */
function createDefaultExportFromLegacySyntax(body) {
  return builders.exportDefaultDeclaration(
    builders.functionDeclaration(
      builders.identifier(TAG_LOGIC_PROPERTY),
      [],
      builders.blockStatement([
        ...compose(
          filterOutAllImportDeclarations,
          filterOutAllExportDeclarations,
        )(body),
        builders.returnStatement(builders.thisExpression()),
      ]),
    ),
  )
}

/**
 * Find all the code in an ast program except for the export default statements
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } array containing all the program code except the export default expressions
 */
function filterNonExportDefaultStatements(body) {
  return body.filter(
    (node) =>
      !isExportDefaultStatement(node) && !isThisExpressionStatement(node),
  )
}

/**
 * Get the body of the AST structure
 * @param   { Object } ast - ast object generated by recast
 * @returns { Array } array containing the program code
 */
function getProgramBody(ast) {
  return ast.body || ast.program.body
}

/**
 * Extend the AST adding the new tag method containing our tag sourcecode
 * @param   { Object } ast - current output ast
 * @param   { Object } exportDefaultNode - tag export default node
 * @returns { Object } the output ast having the "tag" key extended with the content of the export default
 */
function extendTagProperty(ast, exportDefaultNode) {
  types.visit(ast, {
    visitProperty(path) {
      if (path.value.key.name === TAG_LOGIC_PROPERTY) {
        path.value.value = exportDefaultNode.declaration;
        return false
      }

      this.traverse(path);
    },
  });

  return ast
}

/**
 * Generate the component javascript logic
 * @param   { Object } sourceNode - node generated by the riot compiler
 * @param   { string } source - original component source code
 * @param   { Object } meta - compilation meta information
 * @param   { AST } ast - current AST output
 * @returns { AST } the AST generated
 */
function javascript(sourceNode, source, meta, ast) {
  const preprocessorName = getPreprocessorTypeByAttribute(sourceNode);
  const javascriptNode = addLineOffset(
    sourceNode.text.text,
    source,
    sourceNode,
  );
  const { options } = meta;
  const preprocessorOutput = preprocess('javascript', preprocessorName, meta, {
    ...sourceNode,
    text: javascriptNode,
  });
  const inputSourceMap = sourcemapAsJSON(preprocessorOutput.map);
  const generatedAst = generateAST(preprocessorOutput.code, {
    sourceFileName: options.file,
    inputSourceMap: isEmptySourcemap(inputSourceMap) ? null : inputSourceMap,
  });
  const generatedAstBody = getProgramBody(generatedAst);
  const exportDefaultNode = findExportDefaultStatement(generatedAstBody);
  const isLegacyRiotSyntax = isNil(exportDefaultNode);
  const outputBody = getProgramBody(ast);
  const componentInterface = findComponentInterface(generatedAstBody);

  // throw in case of mixed component exports
  if (exportDefaultNode && generatedAstBody.some(isThisExpressionStatement))
    throw new Error(
      'You can\t use "export default {}" and root this statements in the same component',
    )

  // add to the ast the "private" javascript content of our tag script node
  outputBody.unshift(
    ...// for the legacy riot syntax we need to move all the import and (named) export statements outside of the function body
    (isLegacyRiotSyntax
      ? [
          ...findAllImportDeclarations(generatedAstBody),
          ...findAllExportNamedDeclarations(generatedAstBody),
        ]
      : // modern riot syntax will hoist all the private stuff outside of the export default statement
        filterNonExportDefaultStatements(generatedAstBody)),
  );

  // create the public component export properties from the root this statements
  if (isLegacyRiotSyntax)
    extendTagProperty(
      ast,
      createDefaultExportFromLegacySyntax(generatedAstBody),
    );

  // convert the export default adding its content to the component property exported
  if (exportDefaultNode) extendTagProperty(ast, exportDefaultNode);

  return componentInterface
    ? // add the component interface to the component object exported
      addComponentInterfaceToExportedObject(ast, componentInterface)
    : ast
}

/**
 * Create the content of the template function
 * @param   { RiotParser.Node } sourceNode - node generated by the riot compiler
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns {AST.BlockStatement} the content of the template function
 */
function createTemplateFunctionContent(sourceNode, sourceFile, sourceCode) {
  return callTemplateFunction(
    ...build(createRootNode(sourceNode), sourceFile, sourceCode),
  )
}

/**
 * Extend the AST adding the new template property containing our template call to render the component
 * @param   { Object } ast - current output ast
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @param   { RiotParser.Node } sourceNode - node generated by the riot compiler
 * @returns { Object } the output ast having the "template" key
 */
function extendTemplateProperty(ast, sourceFile, sourceCode, sourceNode) {
  types.visit(ast, {
    visitProperty(path) {
      if (path.value.key.name === TAG_TEMPLATE_PROPERTY) {
        path.value.value = createTemplateDependenciesInjectionWrapper(
          createTemplateFunctionContent(sourceNode, sourceFile, sourceCode),
        );

        return false
      }

      this.traverse(path);
    },
  });

  return ast
}

/**
 * Generate the component template logic
 * @param   { RiotParser.Node } sourceNode - node generated by the riot compiler
 * @param   { string } source - original component source code
 * @param   { Object } meta - compilation meta information
 * @param   { AST } ast - current AST output
 * @returns { AST } the AST generated
 */
function template(sourceNode, source, meta, ast) {
  const { options } = meta;
  return extendTemplateProperty(ast, options.file, source, sourceNode)
}

const DEFAULT_OPTIONS = {
  template: 'default',
  file: '[unknown-source-file]',
  scopedCss: true,
};

/**
 * Create the initial AST
 * @param {string} tagName - the name of the component we have compiled
 * @returns { AST } the initial AST
 *
 * @example
 * // the output represents the following string in AST
 */
function createInitialInput({ tagName }) {
  /*
  generates
  export default {
     ${TAG_CSS_PROPERTY}: null,
     ${TAG_LOGIC_PROPERTY}: null,
     ${TAG_TEMPLATE_PROPERTY}: null
  }
  */
  return builders.program([
    builders.exportDefaultDeclaration(
      builders.objectExpression([
        simplePropertyNode(TAG_CSS_PROPERTY, nullNode()),
        simplePropertyNode(TAG_LOGIC_PROPERTY, nullNode()),
        simplePropertyNode(TAG_TEMPLATE_PROPERTY, nullNode()),
        simplePropertyNode(TAG_NAME_PROPERTY, builders.literal(tagName)),
      ]),
    ),
  ])
}

/**
 * Make sure the input sourcemap is valid otherwise we ignore it
 * @param   {SourceMapGenerator} map - preprocessor source map
 * @returns {Object} sourcemap as json or nothing
 */
function normaliseInputSourceMap(map) {
  const inputSourceMap = sourcemapAsJSON(map);
  return isEmptySourcemap(inputSourceMap) ? null : inputSourceMap
}

/**
 * Override the sourcemap content making sure it will always contain the tag source code
 * @param   {Object} map - sourcemap as json
 * @param   {string} source - component source code
 * @returns {Object} original source map with the "sourcesContent" property overridden
 */
function overrideSourcemapContent(map, source) {
  return {
    ...map,
    sourcesContent: [source],
  }
}

/**
 * Create the compilation meta object
 * @param { string } source - source code of the tag we will need to compile
 * @param { string } options - compiling options
 * @returns {Object} meta object
 */
function createMeta(source, options) {
  return {
    tagName: null,
    fragments: null,
    options: {
      ...DEFAULT_OPTIONS,
      ...options,
    },
    source,
  }
}

/**
 * Parse a string to simply get its template AST
 * @param { string } source - string to parse
 * @param { Object } options - parser options
 * @returns {Object} riot parser template output
 */
const parseSimpleString = (source, options) => {
  const { parse } = riotParser(options);
  return parse(source).output.template
};

/**
 * Generate the component slots creation function from the root node
 * @param { string } source - component outer html
 * @param { Object } parserOptions - riot parser options
 * @returns { string } content of the function that can be used to crate the slots in runtime
 */
function generateSlotsFromString(source, parserOptions) {
  return compose(
    ({ code }) => code,
    generateJavascript,
    createTemplateDependenciesInjectionWrapper,
    createSlotsArray,
  )(parseSimpleString(source, parserOptions), DEFAULT_OPTIONS.file, source)
}

/**
 * Generate the Riot.js binding template function from a template string
 * @param { string } source - template string
 * @param { Object } parserOptions - riot parser options
 * @returns { string } Riot.js bindings template function generated
 */
function generateTemplateFunctionFromString(source, parserOptions) {
  return compose(
    ({ code }) => code,
    generateJavascript,
    callTemplateFunction,
  )(
    ...build(
      parseSimpleString(source, parserOptions),
      DEFAULT_OPTIONS.file,
      source,
    ),
  )
}

/**
 * Generate the output code source together with the sourcemap
 * @param { string } source - source code of the tag we will need to compile
 * @param { Object } opts - compiling options
 * @returns { Output } object containing output code and source map
 */
function compile(source, opts = {}) {
  const meta = createMeta(source, opts);
  const { options } = meta;
  const { code, map } = execute(
    'template',
    options.template,
    meta,
    source,
  );
  const { parse } = riotParser(options);
  const { template: template$1, css: css$1, javascript: javascript$1 } = parse(code).output;

  // see also https://github.com/riot/compiler/issues/130
  if (hasHTMLOutsideRootNode(template$1 || css$1 || javascript$1, code, parse)) {
    throw new Error('Multiple HTML root nodes are not supported')
  }

  // extend the meta object with the result of the parsing
  Object.assign(meta, {
    tagName: template$1.name,
    fragments: { template: template$1, css: css$1, javascript: javascript$1 },
  });

  return compose(
    (result) => ({ ...result, meta }),
    (result) => execute$1(result, meta),
    (result) => ({
      ...result,
      map: overrideSourcemapContent(result.map, source),
    }),
    (ast) =>
      (meta.ast =
        ast &&
        generateJavascript(ast, {
          sourceMapName: `${options.file}.map`,
          inputSourceMap: normaliseInputSourceMap(map),
        })),
    hookGenerator(template, template$1, code, meta),
    hookGenerator(javascript, javascript$1, code, meta),
    hookGenerator(css, css$1, code, meta),
  )(createInitialInput(meta))
}

/**
 * Prepare the riot parser node transformers
 * @param   { Function } transformer - transformer function
 * @param   { Object } sourceNode - riot parser node
 * @param   { string } source - component source code
 * @param   { Object } meta - compilation meta information
 * @returns { function(): Promise<Output> } Function what resolves to object containing output code and source map
 */
function hookGenerator(transformer, sourceNode, source, meta) {
  const hasContent =
    sourceNode &&
    (sourceNode.text ||
      !isEmptyArray(sourceNode.nodes) ||
      !isEmptyArray(sourceNode.attributes));

  return hasContent
    ? curry(transformer)(sourceNode, source, meta)
    : (result) => result
}

// This function can be used to register new preprocessors
// a preprocessor can target either only the css or javascript nodes
// or the complete tag source file ('template')
const registerPreprocessor = register;

// This function can allow you to register postprocessors that will parse the output code
// here we can run prettifiers, eslint fixes...
const registerPostprocessor = register$1;

export { compile, createInitialInput, generateSlotsFromString, generateTemplateFunctionFromString, registerPostprocessor, registerPreprocessor };
